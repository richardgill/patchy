{"id":"patchy-1","title":"Implement patchy apply command","description":"The apply command exists but is a stub that only prints 'applying..'. It needs to actually:\n- Copy new files from patches/ to repo_dir\n- Apply .diff files to existing files in repo_dir\n- Handle errors gracefully (missing files, failed patches)\n- Respect --dry-run flag (already shows message, but should list what would be done)\n\nLocation: src/commands/apply/impl.ts:21","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-08T12:28:09.564008556Z","updated_at":"2025-12-08T12:42:25.546227185Z","closed_at":"2025-12-08T12:42:25.546227185Z"}
{"id":"patchy-10","title":"Add confirmation prompt to repo reset command","description":"## Context\n\n`patchy repo reset` runs `git reset --hard` which is a destructive operation that discards all local changes. Users should be prompted to confirm before this happens.\n\n## Proposed Behavior\n\n```\n$ patchy repo reset --repo-base-dir repos --repo-dir my-repo\nThis will discard all uncommitted changes in repos/my-repo. Continue? [y/N]\n```\n\n## Flags (following Vercel CLI pattern)\n\n- `--yes` / `-y` - Skip confirmation prompt and proceed\n- Could also respect `--dry-run` to show what would be reset without prompting\n\n## Implementation\n\n1. Add `yes` flag to `src/commands/repo/reset/command.ts`\n2. Add `YesCommandFlags` or extend `ResetCommandFlags` in `src/config/types.ts`\n3. Update `src/commands/repo/reset/impl.ts:68` to prompt before `git.reset([\"--hard\"])`\n4. Use `enquirer` (already a dependency) for the prompt\n\n## Example from Vercel CLI\n\n```\n$ vercel rm my-project\n\u003e The project \"my-project\" will be removed permanently.\n? Are you sure you want to continue? (y/N)\n```\n\n## File\n\n- src/commands/repo/reset/impl.ts:68","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-08T15:31:27.495652292Z","updated_at":"2025-12-08T17:14:31.504791793Z","closed_at":"2025-12-08T17:14:31.504791793Z"}
{"id":"patchy-11","title":"Convert project bundling from tsdown to bun","description":"Replace tsdown with bun for bundling the CLI. Currently using tsdown (see package.json build script). Bun's bundler offers faster builds and native TypeScript support. Changes needed: update build script, verify output works as CLI, update any related CI/build configs.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T15:49:57.096547195Z","updated_at":"2025-12-08T18:37:27.213882481Z","closed_at":"2025-12-08T18:37:27.213882481Z"}
{"id":"patchy-12","title":"Add dry-run support to repo reset and repo checkout commands","description":"The apply, generate, and repo clone commands all support --dry-run flag, but repo reset and repo checkout do not. These are destructive operations that would benefit from dry-run support to preview what would happen.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-08T17:12:41.783873766Z","updated_at":"2025-12-08T17:15:17.303242242Z","closed_at":"2025-12-08T17:15:17.303242242Z"}
{"id":"patchy-13","title":"Ensure Claude Code web has bd installed via mise","description":"Make sure bd (beads) is configured in mise.toml and that Claude Code web runs 'mise install' to have bd available. This enables automatic context recovery and issue tracking in Claude Code web sessions.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T17:49:55.458250788Z","updated_at":"2025-12-08T18:36:02.982035941Z","closed_at":"2025-12-08T18:36:02.982035941Z"}
{"id":"patchy-14","title":"Explore options for improving e2e test readability","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T18:59:22.299803898Z","updated_at":"2025-12-08T19:24:59.263843205Z","closed_at":"2025-12-08T19:24:59.263843205Z"}
{"id":"patchy-15","title":"Explore CLI distribution patterns (Bun binaries + npm)","description":"# Goal\n\nUnderstand CLI distribution best practices and document how this project handles distribution in CONTRIBUTOR.md.\n\n# Research Tasks\n\n## 1. Research Bun binary distribution\n- Use `gh search code` to find examples of projects distributing CLIs as Bun binaries\n- Understand compilation, cross-platform builds, release workflows\n\n## 2. Research npm distribution\n- How do CLI tools publish to npm?\n- Best practices for bin field, shebang, etc.\n\n## 3. Document this project's approach\n- How does patchy currently handle distribution?\n- Add clear documentation to CONTRIBUTOR.md\n\n# Deliverable\n\nUpdated CONTRIBUTOR.md with clear documentation on how distribution works in this project.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T19:00:05.465209723Z","updated_at":"2025-12-08T19:27:37.425379529Z","closed_at":"2025-12-08T19:27:37.425379529Z","dependencies":[{"issue_id":"patchy-15","depends_on_id":"patchy-16","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"patchy-15","depends_on_id":"patchy-17","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"patchy-16","title":"Research Bun binary CLI distribution patterns","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T19:00:16.245961517Z","updated_at":"2025-12-08T19:26:57.742098386Z","closed_at":"2025-12-08T19:26:57.742098386Z"}
{"id":"patchy-17","title":"Research npm CLI distribution patterns","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T19:00:19.507033879Z","updated_at":"2025-12-08T19:26:57.742105759Z","closed_at":"2025-12-08T19:26:57.742105759Z"}
{"id":"patchy-18","title":"Document patchy distribution in CONTRIBUTOR.md","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T19:00:24.95240206Z","updated_at":"2025-12-08T19:27:37.425407151Z","closed_at":"2025-12-08T19:27:37.425407151Z","dependencies":[{"issue_id":"patchy-18","depends_on_id":"patchy-16","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"patchy-18","depends_on_id":"patchy-17","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"patchy-19","title":"Allow pushes for .beads/ directory on main branch","description":"Configure branch protection or CI to allow direct pushes to main when only .beads/ files are modified. This enables bd issue tracking updates without requiring PRs.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T19:06:56.368385591Z","updated_at":"2025-12-08T19:14:21.035010011Z","closed_at":"2025-12-08T19:14:21.035010011Z"}
{"id":"patchy-2","title":"Implement patchy generate command","description":"The generate command exists but is a stub that only prints 'Generating patches...'. It needs to actually:\n- Detect dirty changes in repo_dir (new files, modified files)\n- Generate .diff files for modified files\n- Copy new files to patches/ directory\n- Mirror the repo_dir directory structure in patches/\n- Respect --dry-run flag (already shows message, but should list what would be generated)\n\nLocation: src/commands/generate/impl.ts:21","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-08T12:28:09.70065921Z","updated_at":"2025-12-08T13:02:51.566735461Z","closed_at":"2025-12-08T13:02:51.566735461Z"}
{"id":"patchy-20","title":"Port opencode's Bun binary distribution pattern to patchy","description":"","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-08T20:47:24.180372425Z","updated_at":"2025-12-08T20:52:36.673636601Z","closed_at":"2025-12-08T20:52:36.673636601Z","dependencies":[{"issue_id":"patchy-20","depends_on_id":"patchy-21","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"patchy-20","depends_on_id":"patchy-22","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"patchy-20","depends_on_id":"patchy-23","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"patchy-20","depends_on_id":"patchy-24","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"patchy-20","depends_on_id":"patchy-25","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"patchy-20","depends_on_id":"patchy-26","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"patchy-21","title":"Create build.ts script for multi-platform Bun compilation","description":"Port opencode's build.ts pattern to compile patchy CLI to standalone binaries for all platforms (linux-x64, linux-arm64, darwin-x64, darwin-arm64, windows-x64). Reference: ~/code/reference-repos/opencode/packages/opencode/script/build.ts","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T20:47:36.064361938Z","updated_at":"2025-12-08T20:52:29.264267273Z","closed_at":"2025-12-08T20:52:29.264267273Z"}
{"id":"patchy-22","title":"Create publish.ts script for npm binary distribution","description":"Port opencode's publish.ts pattern to publish platform-specific packages to npm with optionalDependencies. Reference: ~/code/reference-repos/opencode/packages/opencode/script/publish.ts","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T20:47:36.221371521Z","updated_at":"2025-12-08T20:52:29.264295336Z","closed_at":"2025-12-08T20:52:29.264295336Z","dependencies":[{"issue_id":"patchy-22","depends_on_id":"patchy-21","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"patchy-22","depends_on_id":"patchy-23","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"patchy-22","depends_on_id":"patchy-24","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"patchy-22","depends_on_id":"patchy-26","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"patchy-23","title":"Create postinstall.mjs for binary symlinking","description":"Port opencode's postinstall.mjs to symlink the correct platform binary after npm install. Reference: ~/code/reference-repos/opencode/packages/opencode/script/postinstall.mjs","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T20:47:36.371263965Z","updated_at":"2025-12-08T20:52:29.264279506Z","closed_at":"2025-12-08T20:52:29.264279506Z"}
{"id":"patchy-24","title":"Create bin wrapper script for platform binary resolution","description":"Port opencode's bin/opencode wrapper that finds and executes the correct platform-specific binary. Reference: ~/code/reference-repos/opencode/packages/opencode/bin/opencode","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T20:47:36.5302968Z","updated_at":"2025-12-08T20:52:29.264284245Z","closed_at":"2025-12-08T20:52:29.264284245Z"}
{"id":"patchy-25","title":"Add GitHub Actions workflow for binary releases","description":"Create workflow to build binaries on tag push and upload to GitHub Releases. Consider patterns from lazyshell (native builds) or opencode (cross-compilation).","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T20:47:36.679966787Z","updated_at":"2025-12-08T20:52:29.264288032Z","closed_at":"2025-12-08T20:52:29.264288032Z"}
{"id":"patchy-26","title":"Update package.json for binary distribution","description":"Update package.json with new scripts (build:binary, publish:binary) and prepare structure for optionalDependencies pattern.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T20:47:36.834457328Z","updated_at":"2025-12-08T20:52:29.264291829Z","closed_at":"2025-12-08T20:52:29.264291829Z"}
{"id":"patchy-27","title":"Replace pnpm with bun","description":"Migrate from pnpm to bun for package management. Need to ensure everything still works throughout the migration.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T21:20:14.021335239Z","updated_at":"2025-12-09T17:17:10.193863411Z","closed_at":"2025-12-09T17:17:10.193863411Z","dependencies":[{"issue_id":"patchy-27","depends_on_id":"patchy-28","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"patchy-27","depends_on_id":"patchy-29","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"patchy-28","title":"Investigate replacing vitest with bun test","description":"Evaluate whether to replace vitest with bun's built-in test runner as part of the pnpm-\u003ebun migration. Consider feature parity, compatibility, and migration effort.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T21:20:18.663336822Z","updated_at":"2025-12-09T17:13:48.151114011Z","closed_at":"2025-12-09T17:13:48.151114011Z"}
{"id":"patchy-29","title":"Define verification steps for pnpm-\u003ebun migration","description":"Document how to verify everything still works during and after migration: tests pass, CLI builds, dev workflow works, etc.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T21:20:23.071394269Z","updated_at":"2025-12-09T17:14:23.480681683Z","closed_at":"2025-12-09T17:14:23.480681683Z"}
{"id":"patchy-3","title":"Implement patchy repo reset command","description":"The 'patchy repo reset' command is documented in README but does not exist. It should:\n- Hard reset the Git working tree of repo_dir\n- Discard all local changes (git reset --hard)\n- Accept --repo-dir flag\n- Show appropriate confirmation/output\n\nNeeds: new command structure in src/commands/repo/","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-08T12:28:09.838884021Z","updated_at":"2025-12-08T15:46:03.937064617Z","closed_at":"2025-12-08T15:46:03.937064617Z"}
{"id":"patchy-30","title":"Research binary deployment options","description":"Research how to deploy binary versions of patchy CLI to the same distribution channels. Present options with complexity analysis.\n\nReference: ~/code/reference-repos/opencode for how they handle binary deployment.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T17:14:23.006478518Z","updated_at":"2025-12-09T19:12:24.395770357Z","closed_at":"2025-12-09T19:12:24.395770357Z","dependencies":[{"issue_id":"patchy-30","depends_on_id":"patchy-35","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"patchy-31","title":"Analyze current deployment channels","description":"Document all current distribution methods for patchy CLI (npm, etc.) and understand their binary support capabilities.\n\nReference ~/code/reference-repos/opencode to see how they deploy and what channels they use.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T17:14:32.503159531Z","updated_at":"2025-12-09T19:12:24.395782249Z","closed_at":"2025-12-09T19:12:24.395782249Z"}
{"id":"patchy-32","title":"Research Node.js to binary compilation options","description":"Investigate options for compiling Node.js/TypeScript CLI to native binaries (pkg, nexe, bun compile, deno compile, etc.). Compare tradeoffs.\n\nReference ~/code/reference-repos/opencode to see what compilation approach they use for their Go-based binaries and consider analogous options for Node.js.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T17:14:32.641083064Z","updated_at":"2025-12-09T19:12:24.395785195Z","closed_at":"2025-12-09T19:12:24.395785195Z","dependencies":[{"issue_id":"patchy-32","depends_on_id":"patchy-31","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"patchy-33","title":"Research binary distribution platforms","description":"Investigate platforms for distributing binaries: GitHub Releases, Homebrew, apt/deb, npm with optionalDependencies pattern, etc.\n\nReference ~/code/reference-repos/opencode to see their distribution strategy (GitHub releases, Homebrew tap, etc.) and evaluate what can be replicated for patchy.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T17:14:32.793259366Z","updated_at":"2025-12-09T19:12:24.395787479Z","closed_at":"2025-12-09T19:12:24.395787479Z","dependencies":[{"issue_id":"patchy-33","depends_on_id":"patchy-31","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"patchy-34","title":"Create complexity analysis matrix","description":"Build a comparison matrix of binary deployment options with complexity ratings, maintenance burden, and platform coverage.\n\nUse findings from opencode (~/code/reference-repos/opencode) as a baseline for what a mature binary distribution looks like.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T17:14:32.938790645Z","updated_at":"2025-12-09T19:12:24.395789713Z","closed_at":"2025-12-09T19:12:24.395789713Z","dependencies":[{"issue_id":"patchy-34","depends_on_id":"patchy-32","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"patchy-34","depends_on_id":"patchy-33","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"patchy-35","title":"Present binary deployment recommendations","description":"Synthesize research into actionable recommendations with pros/cons for each approach.\n\nInclude comparison to opencode's approach (~/code/reference-repos/opencode) and note which of their patterns we can adopt vs what requires different solutions for a Node.js CLI.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T17:14:33.085719333Z","updated_at":"2025-12-09T19:12:24.395791807Z","closed_at":"2025-12-09T19:12:24.395791807Z","dependencies":[{"issue_id":"patchy-35","depends_on_id":"patchy-34","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"patchy-36","title":"E2E tests fail on bun test: process.cwd override not working correctly","description":"When running tests with `bun test`, the e2e tests fail because the process.cwd() override in stricli-test-context.ts doesn't work as expected. The CLI commands run in the project root instead of the test's tmpDir. This causes:\n1. Config files to be read from wrong location\n2. Directory validation to fail\n3. Output paths to be wrong\n\nRoot cause: The test framework overrides global process.cwd() but something in bun's execution model doesn't respect this override consistently.\n\nAffected files:\n- src/e2e/stricli-test-context.ts (lines 92-95 override process.cwd)\n- All e2e tests that use runCli()","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T17:38:09.244914031Z","updated_at":"2025-12-09T17:42:28.317294169Z","closed_at":"2025-12-09T17:42:28.317294169Z"}
{"id":"patchy-37","title":"Snapshot whitespace differences between vitest and bun test","description":"When running the same tests with vitest vs bun test, inline snapshots have minor whitespace differences (extra newlines). This causes snapshot comparison failures even when the actual content matches.\n\nExample:\n- vitest: '\"some text\"'\n- bun test: '\\n\"some text\"\\n'\n\nAffected: resolver.test.ts and other unit tests with inline snapshots","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T17:38:16.601527439Z","updated_at":"2025-12-09T17:42:28.317307995Z","closed_at":"2025-12-09T17:42:28.317307995Z"}
{"id":"patchy-38","title":"Replace pnpm with bun as package manager","description":"Update all pnpm commands to bun equivalents in package.json scripts, CI workflows, and documentation. Remove pnpm-lock.yaml and generate bun.lockb.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T17:58:34.938943447Z","updated_at":"2025-12-09T18:07:29.51002092Z","closed_at":"2025-12-09T18:07:29.51002092Z"}
{"id":"patchy-39","title":"Replace vitest with bun test","description":"Migrate test suite from vitest to bun's built-in test runner. Update test syntax, remove vitest dependencies, update test scripts in package.json.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T17:58:35.078133529Z","updated_at":"2025-12-09T18:07:29.510031009Z","closed_at":"2025-12-09T18:07:29.510031009Z"}
{"id":"patchy-4","title":"Implement patchy repo checkout command","description":"The 'patchy repo checkout --ref \u003cgit-ref\u003e' command is documented in README but does not exist. It should:\n- Check out a specific Git ref (branch, tag, or SHA) in repo_dir\n- Accept --ref flag (required)\n- Accept --repo-dir flag\n- Handle errors (invalid ref, dirty working tree)\n\nNeeds: new command structure in src/commands/repo/","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-08T12:28:09.996673342Z","updated_at":"2025-12-08T15:25:55.964447375Z","closed_at":"2025-12-08T15:25:55.964447375Z"}
{"id":"patchy-40","title":"Replace tsx/node with bun runtime","description":"Replace tsx with bun run for executing TypeScript files. Update dev scripts and any node-specific code. Remove tsx dependency.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T17:58:35.219568298Z","updated_at":"2025-12-09T18:07:29.510032983Z","closed_at":"2025-12-09T18:07:29.510032983Z"}
{"id":"patchy-41","title":"Update CI workflows for bun","description":"Update GitHub Actions workflows to use bun instead of pnpm. Replace pnpm/action-setup with oven-sh/setup-bun. Update all workflow commands.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T17:58:35.351387167Z","updated_at":"2025-12-09T18:09:01.822635783Z","closed_at":"2025-12-09T18:09:01.822635783Z","dependencies":[{"issue_id":"patchy-41","depends_on_id":"patchy-38","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"patchy-42","title":"Clean up node/pnpm/vitest dependencies","description":"Remove tsx, vitest, @vitest/coverage-v8, shell-quote, @types/shell-quote from dependencies. Update package.json engines field if needed.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T17:58:35.507432985Z","updated_at":"2025-12-09T18:09:01.822646062Z","closed_at":"2025-12-09T18:09:01.822646062Z","dependencies":[{"issue_id":"patchy-42","depends_on_id":"patchy-38","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"patchy-42","depends_on_id":"patchy-39","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""},{"issue_id":"patchy-42","depends_on_id":"patchy-40","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"patchy-43","title":"Audit and remove unused dependencies","description":"Grep extensively through the codebase to find any dependencies in package.json that are not actually used. Remove any unused deps to keep the project lean.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T20:15:40.33045361Z","updated_at":"2025-12-09T20:23:44.320037206Z","closed_at":"2025-12-09T20:23:44.320037206Z"}
{"id":"patchy-44","title":"Add CONTRIBUTING.md with release instructions","description":"Document the release process in CONTRIBUTING.md. Look extensively at how releases are currently set up (package.json scripts, GitHub Actions workflows, npm publishing, binary builds) and write clear instructions for contributors on how to perform a release.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T20:16:37.772575305Z","updated_at":"2025-12-09T20:21:26.52315025Z","closed_at":"2025-12-09T20:21:26.52315025Z"}
{"id":"patchy-45","title":"Fix broken tests","description":"","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-09T21:57:49.195515517Z","updated_at":"2025-12-09T23:00:00.346800692Z","closed_at":"2025-12-09T23:00:00.346800692Z"}
{"id":"patchy-46","title":"Rename GitHub Actions checks to CI / JobName format","description":"## Goal\nSimplify the verbose nested check names (e.g., 'Publish / Checks / Build') to a flat 'CI / JobName' format.\n\n## Current State\n- Publish / Build binaries and create GitHub release\n- Publish / Checks / Build\n- Publish / Checks / Lint\n- Publish / Checks / Test\n- Publish / Checks / Typecheck\n- Publish / Release\n\n## Desired State\n- CI / Build\n- CI / Lint\n- CI / Test\n- CI / Typecheck\n- CI / Release\n- CI / Binaries\n\n## Implementation\n- Rename workflow to 'CI'\n- Remove nested 'Checks' grouping\n- Set explicit job names: Build, Lint, Test, Typecheck, Release, Binaries","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T22:01:14.261434511Z","updated_at":"2025-12-09T22:25:57.522968082Z","closed_at":"2025-12-09T22:25:57.522968082Z"}
{"id":"patchy-47","title":"Centralize hardcoded project strings for easier scaffolding","description":"## Summary\n\nResearch into all hardcoded \"patchy\" strings and project-specific identifiers across the codebase. This documents locations that would need changes when scaffolding a new project from this template.\n\n## Hardcoded String Categories\n\n### 1. Core Identity (Critical - Must Change)\n\n| File | Line | String | Purpose |\n|------|------|--------|---------|\n| `src/app.ts` | 20 | `name: \"patchy\"` | CLI command name |\n| `package.json` | 2 | `\"name\": \"patchy-cli\"` | npm package name |\n| `src/config/defaults.ts` | 2 | `\"./patchy.json\"` | Default config filename |\n| `script/build.ts` | 9 | `CLI_NAME = \"patchy\"` | Build output binary name |\n| `install` | 5 | `APP=patchy` | Installer app name |\n\n### 2. Repository URLs\n\n| File | Line | String |\n|------|------|--------|\n| `package.json` | 53 | `github.com/richardgill/patchy` |\n| `script/build.ts` | 92 | `github.com/richardgill/patchy.git` |\n| `.changeset/config.json` | 5 | `richardgill/patchy` |\n| `install` | 6 | `REPO=\"richardgill/patchy\"` |\n| `.github/workflows/publish.yml` | 118,124 | GitHub URLs |\n\n### 3. Environment Variable Prefix (PATCHY_*)\n\nDefined in `src/config/types.ts:79-121`:\n- `PATCHY_REPO_URL`\n- `PATCHY_REPO_DIR`\n- `PATCHY_REPO_BASE_DIR`\n- `PATCHY_PATCHES_DIR`\n- `PATCHY_REF`\n- `PATCHY_VERBOSE`\n- `PATCHY_DRY_RUN`\n\nAlso: `PATCHY_CONFIG` in `src/config/resolver.ts:153,155`\nAnd: `PATCHY_VERSION` in `script/build.ts:10`\n\nHelp text references in `src/commands/shared-parameters.ts:6-57`\n\n### 4. Install Directory\n\n| File | Line | String |\n|------|------|--------|\n| `install` | 75 | `INSTALL_DIR=$HOME/.patchy/bin` |\n\n### 5. User-Facing Messages\n\n| File | Line | String |\n|------|------|--------|\n| `src/commands/init/impl.ts` | 68 | `\"Let's set up your Patchy project\"` |\n| `src/commands/init/impl.ts` | 140 | `\"Patchy project initialized successfully!\"` |\n| `src/commands/init/impl.ts` | 143,146 | `\"patchy repo clone\"`, `\"patchy generate\"` |\n| `src/config/resolver.ts` | 235 | `\"patchy init\"` in error guidance |\n\n### 6. Build Artifacts\n\nIn `.github/workflows/publish.yml:94-106`:\n- `patchy-linux-x64`\n- `patchy-linux-arm64`\n- `patchy-darwin-x64`\n- `patchy-darwin-arm64`\n- `patchy-windows-x64`\n\n### 7. Documentation (Lower Priority)\n\n- `README.md:1` - `# patchy` heading\n- `CLAUDE.md:3` - `# Patchy CLI Project`\n- `CONTRIBUTING.md:1` - `# Contributing to Patchy`\n\n### 8. Beads Config\n\n- `.beads/config.yaml:9` - `issue-prefix: \"patchy\"`\n\n### 9. Stale Third-Party Reference (Bug)\n\n`.github/pull_request_template.md:27` references external project:\n`https://github.com/ITZSHOAIB/hashtegrity/blob/master/.github/CONTRIBUTING.md`\n\n## Centralization Strategy\n\n**Option A: Single Constants File**\nCreate `src/constants.ts` or `src/branding.ts`:\n```typescript\nexport const BRAND = {\n  name: \"patchy\",\n  packageName: \"patchy-cli\",\n  configFile: \"patchy.json\",\n  envPrefix: \"PATCHY\",\n  installDir: \".patchy\",\n  repoOwner: \"richardgill\",\n  repoName: \"patchy\",\n} as const\n```\n\n**Option B: Template Variables**\nUse placeholders like `{{PROJECT_NAME}}` and a scaffolding script to replace them.\n\n## Files Requiring Changes by Count\n\n| Category | Files | ~Occurrences |\n|----------|-------|--------------|\n| Test files (e2e + unit) | 8 | ~180 |\n| Documentation | 3 | ~50 |\n| Configuration | 5 | ~30 |\n| Source code | 7 | ~25 |\n| Install script | 1 | 5 |\n| Beads tracker | 2 | ~30 |\n\n## Recommended Priority\n\n1. **First**: Create centralized constants in `src/branding.ts`\n2. **Second**: Update source files to use constants\n3. **Third**: Update build scripts and workflows\n4. **Fourth**: Update install script\n5. **Fifth**: Document scaffolding process for tests and docs","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-09T22:38:08.204517059Z","updated_at":"2025-12-09T23:00:05.33181604Z","closed_at":"2025-12-09T23:00:05.33181604Z"}
{"id":"patchy-48","title":"Create SCAFFOLD.md with Claude Code scaffolding guide","description":"## Summary\n\nCreate a SCAFFOLD.md file that provides precise grep patterns and prompts for Claude Code to scaffold a new project from the patchy template.\n\n## Approach\n\nInstead of a traditional scaffolding script, leverage Claude Code as the scaffolding tool with:\n1. Precise grep patterns for each category of hardcoded strings\n2. Copy-paste prompts for Claude Code to execute replacements\n3. Verification commands to confirm no stray references\n\n## Structure\n\n```markdown\n# Scaffolding Guide for New Project\n\n## Quick Start\nRun this prompt in Claude Code:\n\u003e Scaffold this project with name \"mycli\", env prefix \"MYCLI\", repo \"myorg/mycli\"\n\n## String Categories \u0026 Grep Patterns\n\n### 1. CLI Name (Critical)\n\\`\\`\\`bash\nrg -n '\"patchy\"' src/app.ts script/build.ts\n\\`\\`\\`\nReplace with: your CLI name (lowercase, no spaces)\n\n### 2. Config Filename\n\\`\\`\\`bash\nrg -n 'patchy\\.json' src/\n\\`\\`\\`\nReplace with: `{name}.json`\n\n### 3. Environment Variable Prefix\n\\`\\`\\`bash\nrg -n 'PATCHY_' src/\n\\`\\`\\`\nReplace with: `{ENV_PREFIX}_`\n\n### 4. Repository URLs\n\\`\\`\\`bash\nrg -n 'richardgill/patchy' .\n\\`\\`\\`\nReplace with: `{owner}/{repo}`\n\n... etc for all categories from patchy-47\n```\n\n## Categories to Include\n\nFrom patchy-47 research:\n1. Core Identity (CLI name, package name, config filename)\n2. Repository URLs\n3. Environment Variable Prefix (PATCHY_*)\n4. Install Directory (.patchy)\n5. User-Facing Messages\n6. Build Artifacts\n7. Beads Config\n\n## Verification Section\n\nInclude grep commands to verify no stray references remain:\n```bash\nrg -i 'patchy' src/ script/ --glob '!*.test.ts'\nrg 'richardgill' .\n```\n\n## Notes\n\n- Test files should be listed separately - many strings are intentional fixtures\n- Documentation files (README, CONTRIBUTING) listed as lower priority\n- The .beads/ directory can be deleted entirely for new projects","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-09T22:52:53.410496932Z","updated_at":"2025-12-13T15:46:12.125758456Z","closed_at":"2025-12-13T15:46:12.125758456Z"}
{"id":"patchy-49","title":"Add JSON Schema for patchy.json config","description":"Generate JSON Schema from Zod schema using z.toJSONSchema(), add $schema field to patchy init output pointing to unpkg CDN. Short-term: use https://unpkg.com/patchy-cli/dist/patchy.schema.json. Long-term: submit to SchemaStore for auto-discovery (leave TODO comment in code). See plans/2025-12-09-json-schema-for-config.md","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-09T22:54:00.078226486Z","updated_at":"2025-12-10T07:02:03.025532204Z","closed_at":"2025-12-10T07:02:03.025532204Z"}
{"id":"patchy-5","title":"Implement patchy repo clone command","description":"The 'patchy repo clone --url \u003cgit-url\u003e' command is documented in README but does not exist. It should:\n- Clone a repository into a subdirectory of repo_base_dir\n- Derive target directory name from repo URL\n- Accept --repo-base-dir flag\n- Accept --ref flag to checkout specific ref after clone\n- Accept --repo-url flag\n- Handle errors (invalid URL, directory exists)\n\nNeeds: new command structure in src/commands/repo/","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-08T12:28:10.142754323Z","updated_at":"2025-12-08T14:49:57.768886903Z","closed_at":"2025-12-08T14:49:57.768886903Z"}
{"id":"patchy-50","title":"Refactor and clean up src/config/ folder","description":"## Summary\nThe src/config/ folder contains configuration handling code that could benefit from cleanup and reorganization.\n\n## Current State\n- **defaults.ts** (6 lines) - Simple constants for default values\n- **jsonc.ts** (93 lines) - JSONC parsing with error formatting\n- **resolver.ts** (294 lines) - Main config resolution/merging logic (largest file)\n- **schemas.ts** (29 lines) - Zod schemas for config validation\n- **types.ts** (136 lines) - Type definitions and CONFIG_FIELD_METADATA\n- **validation.ts** (24 lines) - Git URL and path validation helpers\n\n## Potential Improvements\n1. **Consolidate related code**: schemas.ts and types.ts have overlapping concerns (both define config-related types)\n2. **Consider merging small files**: defaults.ts (6 lines) and validation.ts (24 lines) could potentially be merged into more cohesive modules\n3. **Review CONFIG_FIELD_METADATA location**: Currently in types.ts but it's runtime data, not just types\n4. **Simplify resolver.ts**: At 294 lines, this is the largest file and might benefit from extracting some helper functions\n5. **Type duplication**: CompleteJsonConfig in types.ts duplicates what could be derived from the Zod schema in schemas.ts\n6. **Consider barrel export**: No index.ts for cleaner imports from outside the folder","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-10T16:14:24.744718132Z","updated_at":"2025-12-11T17:56:51.987919914Z","closed_at":"2025-12-11T17:56:51.987919914Z"}
{"id":"patchy-51","title":"Replace enquirer with @clack/prompts","description":"# Replace enquirer with @clack/prompts\n\n## Overview\n\nReplace the `enquirer` dependency with `@clack/prompts` for CLI prompts. Clack is 80% smaller, has better TypeScript support, and provides a more modern API.\n\n## Current State Analysis\n\nTwo files use enquirer:\n\n1. **`src/commands/init/impl.ts`** - Uses `input` prompts for:\n   - Repository URL (with validation)\n   - Git ref (with default)\n   - Patches directory (with default)\n\n2. **`src/commands/repo/reset/impl.ts`** - Uses `confirm` prompt for destructive action confirmation\n\nBoth files:\n- Import enquirer as default export, then destructure `prompt`\n- Use `.catch()` for cancellation handling\n- Use TypeScript generics for typed answers\n\n## Desired End State\n\n- `enquirer` removed from dependencies\n- `@clack/prompts` added as dependency\n- Both prompt usages converted to clack API\n- `bun run local-ci` passes (typecheck, check, test)\n\n## What We're NOT Doing\n\n- Adding new prompts or features\n- Changing the UX flow\n- Adding intro/outro styling (keep it simple)\n\n## Implementation Approach\n\nClack uses individual function imports rather than a unified `prompt()` call. The mapping:\n- enquirer `input` â†’ clack `text`\n- enquirer `confirm` â†’ clack `confirm`\n- enquirer validation â†’ clack `validate` option\n- enquirer `.catch()` â†’ clack `isCancel()` check\n\n## Phase 1: Update Dependencies\n\n### Changes Required:\n\n```bash\nbun remove enquirer\nbun add @clack/prompts\n```\n\n---\n\n## Phase 2: Convert init/impl.ts\n\n### File: `src/commands/init/impl.ts`\n\nReplace enquirer import and prompt logic with clack:\n\n**Old pattern:**\n```typescript\nimport enquirer from \"enquirer\";\nconst { prompt } = enquirer;\n// ...\nconst answers = await prompt\u003cPromptAnswers\u003e(questions).catch(() =\u003e {...});\n```\n\n**New pattern:**\n```typescript\nimport * as p from \"@clack/prompts\";\n// ...\n// Sequential prompts with isCancel checks\nconst repoUrl = await p.text({...});\nif (p.isCancel(repoUrl)) { /* handle cancel */ }\n```\n\nKey changes:\n- Import `* as p from \"@clack/prompts\"`\n- Replace conditional question array with sequential `if` blocks\n- Use `p.text()` for input prompts\n- Use `p.isCancel()` to detect cancellation\n- `hint` option maps to `placeholder` in clack\n- `initial` option maps to `initialValue` in clack\n- `validate` function works the same (return string for error, undefined for success)\n\n---\n\n## Phase 3: Convert repo/reset/impl.ts\n\n### File: `src/commands/repo/reset/impl.ts`\n\n**Old pattern:**\n```typescript\nimport enquirer from \"enquirer\";\nconst { prompt } = enquirer;\n// ...\nconst { confirmed } = await prompt\u003c{ confirmed: boolean }\u003e({\n  type: \"confirm\",\n  name: \"confirmed\",\n  message: \"...\",\n  initial: false,\n}).catch(() =\u003e ({ confirmed: false }));\n```\n\n**New pattern:**\n```typescript\nimport * as p from \"@clack/prompts\";\n// ...\nconst confirmed = await p.confirm({\n  message: \"...\",\n  initialValue: false,\n});\nif (p.isCancel(confirmed)) {\n  // handle cancel - treat as not confirmed\n}\n```\n\nKey changes:\n- Import `* as p from \"@clack/prompts\"`\n- Use `p.confirm()` directly (returns boolean, not object)\n- Use `p.isCancel()` for cancellation detection\n- `initial` â†’ `initialValue`\n\n---\n\n## Success Criteria\n\n### Automated Verification:\n- [ ] `bun run local-ci` passes (runs check, typecheck, test in parallel)\n- [ ] No enquirer in package.json dependencies\n- [ ] @clack/prompts in package.json dependencies\n\n### Manual Verification:\n- [ ] `bun run dev init` works interactively\n- [ ] `bun run dev repo reset` shows confirmation prompt\n- [ ] Ctrl+C cancellation works correctly in both commands","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-10T16:15:10.984334519Z","updated_at":"2025-12-10T16:42:15.055153979Z","closed_at":"2025-12-10T16:42:15.055153979Z"}
{"id":"patchy-52","title":"Refine README documentation","description":"## Summary\nReview and improve the README.md to make it clearer and more useful for users.\n\n## Potential Areas to Address\n- Ensure installation instructions are clear and up-to-date\n- Improve usage examples and command documentation\n- Add or refine quick-start guide\n- Review structure and flow for new users\n- Ensure all CLI commands are documented\n- Add badges or status indicators if appropriate","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-10T16:15:42.605061704Z","updated_at":"2025-12-11T12:31:52.383999093Z","closed_at":"2025-12-11T12:31:52.383999093Z"}
{"id":"patchy-53","title":"Cut first release (v1.0.0)","description":"## Summary\nPrepare and publish the first official release of Patchy CLI using changesets\n","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-10T16:15:58.624279075Z","updated_at":"2025-12-10T16:24:31.889913445Z","closed_at":"2025-12-10T16:24:31.889913445Z"}
{"id":"patchy-54","title":"Fix up CONTRIBUTING.md with squash merge setup","description":"## Summary\nImprove CONTRIBUTING.md documentation, including instructions for configuring squash-only merges using the GitHub CLI.\n\n## Tasks\n- Add gh CLI command to configure squash-only merges for the repo:\n  ```bash\n  gh repo edit --enable-squash-merge --disable-merge-commit --disable-rebase-merge\n  ```\n- Ensure development setup instructions are clear\n\n\nalso add instructions to setup delete branch on PR merge using gh command\n\n","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-10T16:19:45.296682231Z","updated_at":"2025-12-11T12:42:08.215841066Z","closed_at":"2025-12-11T12:42:08.215841066Z"}
{"id":"patchy-55","title":"Simplify PR template","description":"# Simplify PR Template\n\n## Overview\n\nThe current PR template is overly verbose with redundant checkboxes and references to a non-existent CONTRIBUTING doc. Simplify to the essentials.\n\n## Current Problems\n\n1. References wrong repo (`ITZSHOAIB/hashtegrity`) in CONTRIBUTING link\n2. Redundant checkboxes (documentation mentioned twice, tests mentioned twice)\n3. \"Type of changes\" checkboxes rarely useful - obvious from diff\n4. Too much friction for small PRs\n\n## Desired End State\n\nMinimal template that captures what matters:\n- Brief description\n- Link to issue (if applicable)\n\n## Proposed Template\n\n```markdown\n## Summary\n\n\u003c!-- Brief description of changes --\u003e\n\n## Related Issue\n\n\u003c!-- Link issue if applicable, or remove this section --\u003e\n```\n\n## Success Criteria\n\n- [ ] Template is under 10 lines\n- [ ] No broken links\n- [ ] No redundant sections","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-10T16:30:26.685947823Z","updated_at":"2025-12-10T21:44:36.023227367Z","closed_at":"2025-12-10T21:44:36.023227367Z"}
{"id":"patchy-56","title":"Add lefthook to run bun install on pull when bun.lock updated","description":"Configure lefthook to automatically run 'bun install' when pulling/merging if bun.lock file has changed. This ensures dependencies stay in sync after pulls without manual intervention.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-10T16:37:48.418410436Z","updated_at":"2025-12-10T17:26:45.472707982Z","closed_at":"2025-12-10T17:26:45.472707982Z"}
{"id":"patchy-57","title":"Publish binaries on PRs for each commit","description":"# PR Binary Publishing Implementation Plan\n\n## Overview\n\nAutomatically publish downloadable binaries for every PR commit, with a sticky PR comment (like Vercel/Netlify deploy previews) showing download instructions. Users should be able to test any PR with a single curl command.\n\n## User Experience Goal\n\nWhen a developer pushes to a PR, they (and reviewers) see a comment like:\n\n```\n## ðŸ”¨ PR Build Ready!\n\n| | |\n|---|---|\n| **Commit** | `abc1234` |\n| **Version** | `0.0.2-pr.123.abc1234` |\n| **Built** | Dec 10, 2025 at 3:45 PM UTC |\n\n### Quick Install\n\ncurl -fsSL https://raw.githubusercontent.com/richardgill/patchy/main/install | bash -s -- --pr 123\n\n### Direct Downloads\n\n| Platform | Architecture | Download |\n|----------|--------------|----------|\n| Linux | x64 | [patchy-linux-x64.tar.gz](https://github.com/.../releases/download/pr-123/...) |\n| Linux | arm64 | [patchy-linux-arm64.tar.gz](https://github.com/.../releases/download/pr-123/...) |\n| macOS | Intel | [patchy-darwin-x64.zip](https://github.com/.../releases/download/pr-123/...) |\n| macOS | Apple Silicon | [patchy-darwin-arm64.zip](https://github.com/.../releases/download/pr-123/...) |\n| Windows | x64 | [patchy-windows-x64.zip](https://github.com/.../releases/download/pr-123/...) |\n\n---\n*This comment updates automatically with each push.*\n```\n\n## Current State Analysis\n\n### Existing Infrastructure\n\n**Install Script** (`install`):\n- Supports `VERSION=x.x.x` env var for specific versions\n- Downloads from `https://github.com/richardgill/patchy/releases/download/v${version}/...`\n- Handles platform detection (linux/darwin/windows, x64/arm64)\n- Already has archive extraction logic (tar.gz for Linux, zip for macOS/Windows)\n\n**Build System** (`scripts/build.ts`):\n- Builds 5 targets: linux-x64, linux-arm64, darwin-x64, darwin-arm64, windows-x64\n- Injects version via `PATCHY_VERSION` environment variable\n- Outputs to `dist/\u003cname\u003e/bin/patchy[.exe]`\n\n**Release Workflow** (`publish.yml`):\n- Creates archives: `patchy-\u003cplatform\u003e.tar.gz` or `.zip`\n- Generates `checksums.txt`\n- Uses `softprops/action-gh-release@v2`\n\n### Key Insight\n\nThe install script already supports versioned downloads - we just need:\n1. A `--pr \u003cnumber\u003e` flag to download from PR releases\n2. PR releases with tag format `pr-\u003cnumber\u003e` (not `v\u003cversion\u003e`)\n\n## Desired End State\n\n1. **Every PR push** creates/updates a GitHub pre-release tagged `pr-\u003cnumber\u003e`\n2. **Sticky PR comment** shows download instructions (updated on each push)\n3. **Install script** supports `--pr 123` flag for one-command installation\n4. **PR merge/close** automatically deletes the pre-release (keeps releases page clean)\n\n### Version Format\n\nPR builds use: `\u003cbase-version\u003e-pr.\u003cpr-number\u003e.\u003cshort-sha\u003e`\n\nExample: `0.0.2-pr.123.abc1234`\n\nThis follows [SemVer pre-release](https://semver.org/#spec-item-9) conventions.\n\n## What We're NOT Doing\n\n- Workflow artifacts (require GitHub login, no stable URLs)\n- External storage (unnecessary complexity)\n- Nightly builds (not requested)\n- npm publishing for PRs\n\n## Implementation Phases\n\n---\n\n## Phase 1: PR Release Workflow\n\n### Overview\n\nCreate a workflow that builds binaries and publishes them as a GitHub pre-release on every PR push.\n\n### Changes Required\n\n#### 1. Create PR release workflow\n\n**File**: `.github/workflows/pr-release.yml`\n\n```yaml\nname: PR Release\n\non:\n  pull_request:\n    types: [opened, synchronize, reopened]\n\npermissions:\n  contents: write\n  pull-requests: write\n\nconcurrency:\n  group: pr-release-${{ github.event.pull_request.number }}\n  cancel-in-progress: true\n\njobs:\n  build-and-release:\n    name: Build \u0026 Release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n\n      - name: Setup Bun\n        uses: oven-sh/setup-bun@v2\n        with:\n          bun-version: \"1.3.4\"\n\n      - name: Install dependencies\n        run: bun install --frozen-lockfile\n\n      - name: Get version info\n        id: version\n        run: |\n          BASE_VERSION=$(node -p \"require('./package.json').version\")\n          SHORT_SHA=$(git rev-parse --short HEAD)\n          PR_NUMBER=${{ github.event.pull_request.number }}\n          VERSION=\"${BASE_VERSION}-pr.${PR_NUMBER}.${SHORT_SHA}\"\n          echo \"version=$VERSION\" \u003e\u003e $GITHUB_OUTPUT\n          echo \"short_sha=$SHORT_SHA\" \u003e\u003e $GITHUB_OUTPUT\n          echo \"pr_number=$PR_NUMBER\" \u003e\u003e $GITHUB_OUTPUT\n          echo \"tag=pr-${PR_NUMBER}\" \u003e\u003e $GITHUB_OUTPUT\n\n      - name: Build all binaries\n        run: bun run build\n        env:\n          PATCHY_VERSION: ${{ steps.version.outputs.version }}\n\n      - name: Prepare release assets\n        run: |\n          mkdir -p release\n\n          # Copy binaries to release folder\n          cp dist/patchy-linux-x64/bin/patchy release/patchy-linux-x64\n          cp dist/patchy-linux-arm64/bin/patchy release/patchy-linux-arm64\n          cp dist/patchy-darwin-x64/bin/patchy release/patchy-darwin-x64\n          cp dist/patchy-darwin-arm64/bin/patchy release/patchy-darwin-arm64\n          cp dist/patchy-windows-x64/bin/patchy.exe release/patchy-windows-x64.exe\n\n          # Create archives\n          cd release\n          tar -czf patchy-linux-x64.tar.gz patchy-linux-x64\n          tar -czf patchy-linux-arm64.tar.gz patchy-linux-arm64\n          zip patchy-darwin-x64.zip patchy-darwin-x64\n          zip patchy-darwin-arm64.zip patchy-darwin-arm64\n          zip patchy-windows-x64.zip patchy-windows-x64.exe\n\n          sha256sum *.tar.gz *.zip \u003e checksums.txt\n\n      - name: Delete existing release (if any)\n        run: gh release delete ${{ steps.version.outputs.tag }} --yes || true\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Create PR release\n        uses: softprops/action-gh-release@v2\n        with:\n          tag_name: ${{ steps.version.outputs.tag }}\n          name: \"PR #${{ steps.version.outputs.pr_number }} Preview\"\n          body: |\n            **Preview build for PR #${{ steps.version.outputs.pr_number }}**\n\n            - Commit: `${{ steps.version.outputs.short_sha }}`\n            - Version: `${{ steps.version.outputs.version }}`\n\n            This is an automated pre-release for testing. It will be deleted when the PR is merged or closed.\n          prerelease: true\n          files: |\n            release/patchy-linux-x64.tar.gz\n            release/patchy-linux-arm64.tar.gz\n            release/patchy-darwin-x64.zip\n            release/patchy-darwin-arm64.zip\n            release/patchy-windows-x64.zip\n            release/checksums.txt\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Post PR comment\n        uses: marocchino/sticky-pull-request-comment@v2\n        with:\n          header: pr-build\n          message: |\n            ## ðŸ”¨ PR Build Ready!\n\n            | | |\n            |---|---|\n            | **Commit** | `${{ steps.version.outputs.short_sha }}` |\n            | **Version** | `${{ steps.version.outputs.version }}` |\n\n            ### Quick Install\n\n            ```bash\n            curl -fsSL https://raw.githubusercontent.com/richardgill/patchy/main/install | bash -s -- --pr ${{ steps.version.outputs.pr_number }}\n            ```\n\n            ### Direct Downloads\n\n            | Platform | Architecture | Download |\n            |----------|--------------|----------|\n            | Linux | x64 | [patchy-linux-x64.tar.gz](https://github.com/richardgill/patchy/releases/download/${{ steps.version.outputs.tag }}/patchy-linux-x64.tar.gz) |\n            | Linux | arm64 | [patchy-linux-arm64.tar.gz](https://github.com/richardgill/patchy/releases/download/${{ steps.version.outputs.tag }}/patchy-linux-arm64.tar.gz) |\n            | macOS | Intel | [patchy-darwin-x64.zip](https://github.com/richardgill/patchy/releases/download/${{ steps.version.outputs.tag }}/patchy-darwin-x64.zip) |\n            | macOS | Apple Silicon | [patchy-darwin-arm64.zip](https://github.com/richardgill/patchy/releases/download/${{ steps.version.outputs.tag }}/patchy-darwin-arm64.zip) |\n            | Windows | x64 | [patchy-windows-x64.zip](https://github.com/richardgill/patchy/releases/download/${{ steps.version.outputs.tag }}/patchy-windows-x64.zip) |\n\n            \u003cdetails\u003e\n            \u003csummary\u003eManual installation\u003c/summary\u003e\n\n            ```bash\n            # Download (replace PLATFORM with: linux-x64, linux-arm64, darwin-x64, darwin-arm64, or windows-x64)\n            curl -fsSL https://github.com/richardgill/patchy/releases/download/${{ steps.version.outputs.tag }}/patchy-PLATFORM.tar.gz | tar -xz\n\n            # Make executable and run\n            chmod +x patchy-*\n            ./patchy-* --version\n            ```\n\n            \u003c/details\u003e\n\n            ---\n            \u003csub\u003eðŸ¤– This comment updates automatically with each push. [View release](https://github.com/richardgill/patchy/releases/tag/${{ steps.version.outputs.tag }})\u003c/sub\u003e\n```\n\n### Success Criteria\n\n#### Automated Verification:\n- [ ] Workflow runs successfully on PR push\n- [ ] Pre-release appears at `https://github.com/richardgill/patchy/releases/tag/pr-\u003cnumber\u003e`\n- [ ] All 5 platform binaries are attached to the release\n\n#### Manual Verification:\n- [ ] PR comment appears with correct formatting\n- [ ] Direct download links work (no login required)\n- [ ] Downloaded binary shows correct version: `patchy --version` â†’ `0.0.2-pr.123.abc1234`\n- [ ] Pushing another commit updates the comment and release\n\n**Implementation Note**: After completing this phase, pause for manual verification before proceeding.\n\n---\n\n## Phase 2: Install Script PR Support\n\n### Overview\n\nAdd `--pr \u003cnumber\u003e` flag to the install script so users can install PR builds with one command.\n\n### Changes Required\n\n#### 1. Update install script\n\n**File**: `install`\n\nAdd PR support near the top after the existing variables:\n\n```bash\n# Near line 13, after: requested_version=${VERSION:-}\nrequested_pr=${PR:-}\n\n# Parse command line arguments\nwhile [[ $# -gt 0 ]]; do\n  case $1 in\n    --pr)\n      requested_pr=\"$2\"\n      shift 2\n      ;;\n    --version)\n      requested_version=\"$2\"\n      shift 2\n      ;;\n    *)\n      echo -e \"${RED}Unknown option: $1${NC}\"\n      exit 1\n      ;;\n  esac\ndone\n```\n\nUpdate the download URL logic (around line 79):\n\n```bash\n# Determine download URL\nif [ -n \"$requested_pr\" ]; then\n  # PR build - uses pr-\u003cnumber\u003e tag format\n  url=\"https://github.com/$REPO/releases/download/pr-${requested_pr}/$filename\"\n  specific_version=\"pr-${requested_pr}\"\n  print_message info \"${MUTED}Installing PR #${requested_pr} preview build${NC}\"\nelif [ -z \"$requested_version\" ]; then\n  url=\"https://github.com/$REPO/releases/latest/download/$filename\"\n  specific_version=$(curl -s \"https://api.github.com/repos/$REPO/releases/latest\" | sed -n 's/.*\"tag_name\": *\"v\\([^\"]*\\)\".*/\\1/p')\n\n  if [[ $? -ne 0 || -z \"$specific_version\" ]]; then\n    echo -e \"${RED}Failed to fetch version information${NC}\"\n    exit 1\n  fi\nelse\n  url=\"https://github.com/$REPO/releases/download/v${requested_version}/$filename\"\n  specific_version=$requested_version\nfi\n```\n\nUpdate the success message at the end to handle PR installs:\n\n```bash\n# Around line 193, update the success message\necho \"\"\nprint_message success \"Installation complete!\"\necho \"\"\nif [ -n \"$requested_pr\" ]; then\n  echo -e \"${MUTED}Installed PR #${requested_pr} preview build${NC}\"\n  echo -e \"${MUTED}Note: This is a pre-release build for testing.${NC}\"\n  echo \"\"\nfi\necho -e \"${MUTED}To get started:${NC}\"\necho \"\"\necho -e \"  ${GREEN}patchy --help${NC}\"\necho \"\"\n```\n\n### Success Criteria\n\n#### Automated Verification:\n- [ ] Script syntax is valid: `bash -n install`\n\n#### Manual Verification:\n- [ ] `curl -fsSL .../install | bash -s -- --pr 123` installs the PR build\n- [ ] `PR=123 curl -fsSL .../install | bash` also works (env var)\n- [ ] Installed binary shows PR version\n- [ ] Regular install (no --pr flag) still works\n\n**Implementation Note**: After completing this phase, pause for manual verification before proceeding.\n\n---\n\n## Phase 3: Cleanup on PR Close\n\n### Overview\n\nAutomatically delete PR pre-releases when the PR is merged or closed to keep the releases page clean.\n\n### Changes Required\n\n#### 1. Create cleanup workflow\n\n**File**: `.github/workflows/pr-release-cleanup.yml`\n\n```yaml\nname: PR Release Cleanup\n\non:\n  pull_request:\n    types: [closed]\n\npermissions:\n  contents: write\n\njobs:\n  cleanup:\n    name: Delete PR Release\n    runs-on: ubuntu-latest\n    steps:\n      - name: Delete PR release and tag\n        run: |\n          PR_NUMBER=${{ github.event.pull_request.number }}\n          TAG=\"pr-${PR_NUMBER}\"\n\n          echo \"Cleaning up release for PR #${PR_NUMBER}...\"\n\n          # Delete the release (if exists)\n          gh release delete \"$TAG\" --repo \"${{ github.repository }}\" --yes || echo \"No release to delete\"\n\n          # Delete the tag (if exists)\n          gh api --method DELETE \"/repos/${{ github.repository }}/git/refs/tags/${TAG}\" || echo \"No tag to delete\"\n\n          echo \"Cleanup complete\"\n        env:\n          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n```\n\n### Success Criteria\n\n#### Automated Verification:\n- [ ] Workflow YAML is valid\n\n#### Manual Verification:\n- [ ] Merge a test PR\n- [ ] Verify the `pr-\u003cnumber\u003e` release is deleted\n- [ ] Verify the `pr-\u003cnumber\u003e` tag is deleted\n- [ ] Close (without merge) another test PR and verify cleanup\n\n**Implementation Note**: After completing this phase, pause for manual verification.\n\n---\n\n## Phase 4: Integration with Existing CI\n\n### Overview\n\nEnsure PR releases only happen after checks pass, and update documentation.\n\n### Changes Required\n\n#### 1. Add dependency on checks (optional enhancement)\n\nIf we want PR releases to only happen after lint/typecheck/test pass, we can make `pr-release.yml` depend on `pre-checks.yml`:\n\n```yaml\n# In pr-release.yml, add at the top of jobs section:\njobs:\n  checks:\n    uses: ./.github/workflows/pre-checks.yml\n    secrets: inherit\n\n  build-and-release:\n    name: Build \u0026 Release\n    needs: checks\n    runs-on: ubuntu-latest\n    # ... rest of job\n```\n\n**Decision**: This is optional. Building before checks complete lets users test faster, but might publish broken builds. Recommend adding the dependency for safety.\n\n#### 2. Update CONTRIBUTING.md (if exists)\n\nAdd section about PR previews:\n\n```markdown\n## Testing PR Builds\n\nEvery pull request automatically publishes preview binaries. To test a PR:\n\n\\`\\`\\`bash\n# Install PR build (replace 123 with the PR number)\ncurl -fsSL https://raw.githubusercontent.com/richardgill/patchy/main/install | bash -s -- --pr 123\n\n# Or download directly from the PR's release page\n\\`\\`\\`\n\nPreview builds are automatically deleted when the PR is merged or closed.\n```\n\n### Success Criteria\n\n#### Automated Verification:\n- [ ] CI passes with new workflow dependencies\n\n#### Manual Verification:\n- [ ] End-to-end flow works: push â†’ checks â†’ release â†’ comment\n- [ ] Documentation is clear\n\n---\n\n## Testing Strategy\n\n### Automated Tests\n\nThe existing CI validates:\n- Build compiles for all platforms\n- Lint, typecheck, and tests pass\n\n### Manual Testing Checklist\n\n1. **Create test PR**\n   - [ ] Push a commit\n   - [ ] Wait for workflow to complete\n   - [ ] Verify sticky comment appears\n\n2. **Verify downloads**\n   - [ ] Click direct download link â†’ downloads without login\n   - [ ] Run `curl ... | bash -s -- --pr \u003cnumber\u003e` â†’ installs correctly\n   - [ ] Run `patchy --version` â†’ shows `x.x.x-pr.\u003cnumber\u003e.\u003csha\u003e`\n\n3. **Verify updates**\n   - [ ] Push another commit to same PR\n   - [ ] Verify comment updates (same comment, new SHA)\n   - [ ] Verify release assets update\n\n4. **Verify cleanup**\n   - [ ] Merge the PR\n   - [ ] Verify release is deleted from releases page\n   - [ ] Verify tag is deleted\n\n5. **Verify existing install still works**\n   - [ ] `curl ... | bash` (no flags) installs latest stable\n   - [ ] `VERSION=x.x.x curl ... | bash` installs specific version\n\n## File Summary\n\n| File | Action | Purpose |\n|------|--------|---------|\n| `.github/workflows/pr-release.yml` | Create | Build and publish PR pre-releases |\n| `.github/workflows/pr-release-cleanup.yml` | Create | Delete releases on PR close |\n| `install` | Modify | Add `--pr \u003cnumber\u003e` flag support |\n| `CONTRIBUTING.md` | Modify | Document PR preview feature |\n\n## References\n\n- [Vercel PR comment format](https://vercel.com/docs/git/vercel-for-github) - Inspiration for sticky comment design\n- [Netlify deploy previews](https://docs.netlify.com/deploy/deploy-types/deploy-previews/) - Similar UX pattern\n- [marocchino/sticky-pull-request-comment](https://github.com/marocchino/sticky-pull-request-comment) - GitHub Action for sticky comments\n- [softprops/action-gh-release](https://github.com/softprops/action-gh-release) - GitHub Action for releases\n- [SemVer pre-release format](https://semver.org/#spec-item-9) - Version naming convention\n- Current install script: `install`\n- Current release workflow: `.github/workflows/publish.yml`","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-10T18:08:40.147045294Z","updated_at":"2025-12-11T12:31:42.723826546Z","closed_at":"2025-12-11T12:31:42.723826546Z"}
{"id":"patchy-58","title":"Publish to npm (wrapper for bun binary)","description":"Add npm publishing to the release workflow. The npm package should wrap the bun binary so users can install via npm/npx.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-10T18:09:20.367343678Z","updated_at":"2025-12-11T12:31:38.704902701Z","closed_at":"2025-12-11T12:31:38.704902701Z"}
{"id":"patchy-59","title":"Implement npm publishing for PR and main workflows","description":"# npm Publishing Implementation Plan\n\n## Overview\n\nAdd npm publishing to both PR and main workflows. Users can install via:\n- `npm install patchy-cli` (stable)\n- `npm install patchy-cli@pr-123` (PR preview)\n\nUses platform-specific packages (`patchy-cli-linux-x64`, etc.) with a thin Node.js wrapper that finds and executes the correct binary at runtime.\n\n## Current State Analysis\n\n### What exists:\n- Binary builds for 5 platforms via `scripts/build.ts`\n- PR workflow publishes to GitHub Releases with tag `pr-{number}`\n- Main workflow uses changesets, publishes to GitHub Releases\n- Build script already generates platform-specific `package.json` files (but missing `publishConfig`)\n\n### What's missing:\n- Node.js shim (`bin/patchy`) to find and run the correct binary\n- `optionalDependencies` in root `package.json`\n- npm publish steps in workflows\n- NPM_TOKEN secret in GitHub\n\n## Desired End State\n\nAfter implementation:\n1. Every PR push publishes to npm with version `X.X.X-pr.{number}.{sha}` and tag `pr-{number}`\n2. Every main release (via changesets) publishes to npm with `latest` tag\n3. Users can install via `npm install patchy-cli` or `npx patchy-cli`\n4. PR comment includes npm install command\n\n### Verification:\n- `npm install patchy-cli` installs wrapper + correct platform binary\n- `npx patchy-cli --version` outputs version\n- PR builds appear on npm with correct tags\n\n## What We're NOT Doing\n\n- Homebrew/AUR publishing (future work)\n- Postinstall symlink (using runtime shim instead)\n- musl/AVX2 variants (just glibc for now)\n\n## Implementation Approach\n\nFollow opencode's pattern: platform packages as optionalDependencies, Node.js shim finds binary at runtime.\n\n---\n\n## Phase 1: Create Node.js Wrapper\n\n### Overview\nCreate the bin shim that finds and executes the platform-specific binary.\n\n### Changes Required:\n\n#### 1. Create `bin/patchy`\n**File**: `bin/patchy` (new)\n\n```javascript\n#!/usr/bin/env node\n\nconst childProcess = require(\"child_process\")\nconst fs = require(\"fs\")\nconst path = require(\"path\")\nconst os = require(\"os\")\n\nconst run = (target) =\u003e {\n  const result = childProcess.spawnSync(target, process.argv.slice(2), {\n    stdio: \"inherit\",\n  })\n  if (result.error) {\n    console.error(result.error.message)\n    process.exit(1)\n  }\n  const code = typeof result.status === \"number\" ? result.status : 0\n  process.exit(code)\n}\n\nconst envPath = process.env.PATCHY_BIN_PATH\nif (envPath) {\n  run(envPath)\n}\n\nconst scriptPath = fs.realpathSync(__filename)\nconst scriptDir = path.dirname(scriptPath)\n\nconst platformMap = {\n  darwin: \"darwin\",\n  linux: \"linux\",\n  win32: \"windows\",\n}\nconst archMap = {\n  x64: \"x64\",\n  arm64: \"arm64\",\n}\n\nlet platform = platformMap[os.platform()]\nif (!platform) {\n  platform = os.platform()\n}\nlet arch = archMap[os.arch()]\nif (!arch) {\n  arch = os.arch()\n}\n\nconst base = \"patchy-cli-\" + platform + \"-\" + arch\nconst binary = platform === \"windows\" ? \"patchy.exe\" : \"patchy\"\n\nconst findBinary = (startDir) =\u003e {\n  let current = startDir\n  for (;;) {\n    const modules = path.join(current, \"node_modules\")\n    if (fs.existsSync(modules)) {\n      const entries = fs.readdirSync(modules)\n      for (const entry of entries) {\n        if (!entry.startsWith(base)) {\n          continue\n        }\n        const candidate = path.join(modules, entry, \"bin\", binary)\n        if (fs.existsSync(candidate)) {\n          return candidate\n        }\n      }\n    }\n    const parent = path.dirname(current)\n    if (parent === current) {\n      return\n    }\n    current = parent\n  }\n}\n\nconst resolved = findBinary(scriptDir)\nif (!resolved) {\n  console.error(\n    'Could not find the patchy binary for your platform. Try manually installing \"' +\n      base +\n      '\"'\n  )\n  process.exit(1)\n}\n\nrun(resolved)\n```\n\n#### 2. Update root `package.json`\n**File**: `package.json`\n\nAdd/modify these fields:\n\n```json\n{\n  \"bin\": {\n    \"patchy\": \"./bin/patchy\"\n  },\n  \"files\": [\n    \"bin\"\n  ],\n  \"optionalDependencies\": {\n    \"patchy-cli-linux-x64\": \"0.0.2\",\n    \"patchy-cli-linux-arm64\": \"0.0.2\",\n    \"patchy-cli-darwin-x64\": \"0.0.2\",\n    \"patchy-cli-darwin-arm64\": \"0.0.2\",\n    \"patchy-cli-windows-x64\": \"0.0.2\"\n  },\n  \"publishConfig\": {\n    \"access\": \"public\"\n  }\n}\n```\n\nNote: The `optionalDependencies` versions will be updated dynamically during publish.\n\n### Success Criteria:\n\n#### Automated Verification:\n- [ ] `bun run check` passes (lint)\n- [ ] `bun run typecheck` passes\n\n#### Manual Verification:\n- [ ] `node bin/patchy` runs (will fail to find binary, but shim executes)\n\n---\n\n## Phase 2: Update Build Script\n\n### Overview\nEnsure platform packages have correct naming and publishConfig.\n\n### Changes Required:\n\n#### 1. Update `scripts/build.ts`\n**File**: `scripts/build.ts`\n\nChange the package name generation and add publishConfig:\n\n```typescript\n// Around line 54-59, update the name generation:\nconst name = [\n  \"patchy-cli\",  // Changed from CLI_NAME (\"patchy\")\n  item.os === \"win32\" ? \"windows\" : item.os,\n  item.arch,\n].join(\"-\");\n\n// Around line 83-100, update the package.json write:\nawait Bun.file(`dist/${name}/package.json`).write(\n  JSON.stringify(\n    {\n      name,\n      version,\n      description: `patchy-cli binary for ${item.os} ${item.arch}`,\n      os: [item.os],\n      cpu: [item.arch],\n      license: \"MIT\",\n      repository: {\n        type: \"git\",\n        url: \"git+https://github.com/richardgill/patchy.git\",\n      },\n      publishConfig: {\n        access: \"public\",\n      },\n    },\n    null,\n    2,\n  ),\n);\n```\n\n### Success Criteria:\n\n#### Automated Verification:\n- [ ] `bun run build` succeeds\n- [ ] `cat dist/patchy-cli-linux-x64/package.json` shows correct name and publishConfig\n\n#### Manual Verification:\n- [ ] Binary in `dist/patchy-cli-linux-x64/bin/patchy` executes\n\n---\n\n## Phase 3: Add npm Publishing to PR Workflow\n\n### Overview\nAdd npm publish step after binary build in PR workflow.\n\n### Changes Required:\n\n#### 1. Update `.github/workflows/pr-release.yml`\n**File**: `.github/workflows/pr-release.yml`\n\nAdd a new job after `build` and before `release`:\n\n```yaml\n  npm-publish:\n    name: Publish to npm\n    needs: [version, build]\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n\n      - name: Setup Bun\n        uses: oven-sh/setup-bun@v2\n        with:\n          bun-version: latest\n\n      - name: Download release assets\n        uses: actions/download-artifact@v4\n        with:\n          name: release-assets\n          path: dist-archives\n\n      - name: Extract binaries for npm publish\n        run: |\n          mkdir -p dist\n          cd dist-archives\n          for archive in *.tar.gz; do\n            name=\"${archive%.tar.gz}\"\n            mkdir -p \"../dist/patchy-cli-${name#patchy-}/bin\"\n            tar -xzf \"$archive\" -C \"../dist/patchy-cli-${name#patchy-}/bin\"\n          done\n          for archive in *.zip; do\n            name=\"${archive%.zip}\"\n            mkdir -p \"../dist/patchy-cli-${name#patchy-}/bin\"\n            unzip -q \"$archive\" -d \"../dist/patchy-cli-${name#patchy-}/bin\"\n          done\n\n      - name: Setup npm auth\n        run: echo \"//registry.npmjs.org/:_authToken=${{ secrets.NPM_TOKEN }}\" \u003e ~/.npmrc\n\n      - name: Publish platform packages\n        run: |\n          VERSION=\"${{ needs.version.outputs.version }}\"\n          TAG=\"pr-${{ needs.version.outputs.pr_number }}\"\n\n          for dir in dist/patchy-cli-*/; do\n            name=$(basename \"$dir\")\n            echo \"Publishing $name@$VERSION with tag $TAG\"\n\n            # Create package.json for this platform package\n            cat \u003e \"$dir/package.json\" \u003c\u003c EOF\n          {\n            \"name\": \"$name\",\n            \"version\": \"$VERSION\",\n            \"description\": \"patchy-cli binary for ${name#patchy-cli-}\",\n            \"os\": [\"$(echo $name | cut -d- -f3 | sed 's/windows/win32/')\"],\n            \"cpu\": [\"$(echo $name | cut -d- -f4)\"],\n            \"license\": \"MIT\",\n            \"repository\": {\n              \"type\": \"git\",\n              \"url\": \"git+https://github.com/richardgill/patchy.git\"\n            },\n            \"publishConfig\": {\n              \"access\": \"public\"\n            }\n          }\n          EOF\n\n            cd \"$dir\"\n            npm publish --access public --tag \"$TAG\"\n            cd -\n          done\n\n      - name: Publish main package\n        run: |\n          VERSION=\"${{ needs.version.outputs.version }}\"\n          TAG=\"pr-${{ needs.version.outputs.pr_number }}\"\n\n          # Update package.json with version and optionalDependencies\n          node -e \"\n            const pkg = require('./package.json');\n            pkg.version = '$VERSION';\n            pkg.optionalDependencies = {\n              'patchy-cli-linux-x64': '$VERSION',\n              'patchy-cli-linux-arm64': '$VERSION',\n              'patchy-cli-darwin-x64': '$VERSION',\n              'patchy-cli-darwin-arm64': '$VERSION',\n              'patchy-cli-windows-x64': '$VERSION'\n            };\n            require('fs').writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\\n');\n          \"\n\n          npm publish --access public --tag \"$TAG\"\n```\n\n#### 2. Update PR comment in release job\n**File**: `.github/workflows/pr-release.yml`\n\nAdd npm install option to the PR comment (in the `release` job):\n\n```yaml\n            ### Install via npm\n\n            ```bash\n            npm install -g patchy-cli@pr-${{ needs.version.outputs.pr_number }}\n            ```\n\n            Or use directly:\n\n            ```bash\n            npx patchy-cli@pr-${{ needs.version.outputs.pr_number }} --version\n            ```\n```\n\n### Success Criteria:\n\n#### Automated Verification:\n- [ ] Workflow syntax is valid: `gh workflow view pr-release.yml`\n\n#### Manual Verification:\n- [ ] Open a test PR, verify packages appear on npm with `pr-{number}` tag\n- [ ] `npx patchy-cli@pr-{number} --version` works\n\n**Implementation Note**: Requires `NPM_TOKEN` secret to be set in GitHub repository settings.\n\n---\n\n## Phase 4: Add npm Publishing to Main Workflow\n\n### Overview\nAdd npm publish step to the main release workflow.\n\n### Changes Required:\n\n#### 1. Update `.github/workflows/publish.yml`\n**File**: `.github/workflows/publish.yml`\n\nAdd `npm-publish` job after `build` and update `publish` to depend on it:\n\n```yaml\n  npm-publish:\n    name: Publish to npm\n    needs: [release, build]\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n\n      - name: Setup Bun\n        uses: oven-sh/setup-bun@v2\n        with:\n          bun-version: latest\n\n      - name: Download release assets\n        uses: actions/download-artifact@v4\n        with:\n          name: release-assets\n          path: dist-archives\n\n      - name: Extract binaries for npm publish\n        run: |\n          mkdir -p dist\n          cd dist-archives\n          for archive in *.tar.gz; do\n            name=\"${archive%.tar.gz}\"\n            mkdir -p \"../dist/patchy-cli-${name#patchy-}/bin\"\n            tar -xzf \"$archive\" -C \"../dist/patchy-cli-${name#patchy-}/bin\"\n          done\n          for archive in *.zip; do\n            name=\"${archive%.zip}\"\n            mkdir -p \"../dist/patchy-cli-${name#patchy-}/bin\"\n            unzip -q \"$archive\" -d \"../dist/patchy-cli-${name#patchy-}/bin\"\n          done\n\n      - name: Setup npm auth\n        run: echo \"//registry.npmjs.org/:_authToken=${{ secrets.NPM_TOKEN }}\" \u003e ~/.npmrc\n\n      - name: Publish platform packages\n        run: |\n          VERSION=\"${{ needs.release.outputs.version }}\"\n\n          for dir in dist/patchy-cli-*/; do\n            name=$(basename \"$dir\")\n            echo \"Publishing $name@$VERSION\"\n\n            cat \u003e \"$dir/package.json\" \u003c\u003c EOF\n          {\n            \"name\": \"$name\",\n            \"version\": \"$VERSION\",\n            \"description\": \"patchy-cli binary for ${name#patchy-cli-}\",\n            \"os\": [\"$(echo $name | cut -d- -f3 | sed 's/windows/win32/')\"],\n            \"cpu\": [\"$(echo $name | cut -d- -f4)\"],\n            \"license\": \"MIT\",\n            \"repository\": {\n              \"type\": \"git\",\n              \"url\": \"git+https://github.com/richardgill/patchy.git\"\n            },\n            \"publishConfig\": {\n              \"access\": \"public\"\n            }\n          }\n          EOF\n\n            cd \"$dir\"\n            npm publish --access public --tag latest\n            cd -\n          done\n\n      - name: Publish main package\n        run: |\n          VERSION=\"${{ needs.release.outputs.version }}\"\n\n          node -e \"\n            const pkg = require('./package.json');\n            pkg.version = '$VERSION';\n            pkg.optionalDependencies = {\n              'patchy-cli-linux-x64': '$VERSION',\n              'patchy-cli-linux-arm64': '$VERSION',\n              'patchy-cli-darwin-x64': '$VERSION',\n              'patchy-cli-darwin-arm64': '$VERSION',\n              'patchy-cli-windows-x64': '$VERSION'\n            };\n            require('fs').writeFileSync('package.json', JSON.stringify(pkg, null, 2) + '\\n');\n          \"\n\n          npm publish --access public --tag latest\n\n  publish:\n    name: Publish Release\n    needs: [release, build, npm-publish]  # Add npm-publish dependency\n    # ... rest unchanged\n```\n\n### Success Criteria:\n\n#### Automated Verification:\n- [ ] Workflow syntax is valid\n\n#### Manual Verification:\n- [ ] Create a changeset, merge release PR\n- [ ] Verify `npm install patchy-cli` works\n- [ ] Verify `npx patchy-cli --version` outputs correct version\n\n---\n\n## Phase 5: Setup and Documentation\n\n### Overview\nAdd NPM_TOKEN secret and update documentation.\n\n### Changes Required:\n\n#### 1. Add NPM_TOKEN to GitHub Secrets\n- Go to repo Settings \u003e Secrets and variables \u003e Actions\n- Add `NPM_TOKEN` with npm automation token\n\n#### 2. Update README install instructions\n**File**: `README.md`\n\nAdd npm installation option alongside curl install.\n\n### Success Criteria:\n\n#### Manual Verification:\n- [ ] NPM_TOKEN secret is set\n- [ ] README shows npm install option\n\n---\n\n## Testing Strategy\n\n### Integration Tests:\n1. PR workflow: Open test PR, verify npm packages published with `pr-{number}` tag\n2. Main workflow: Merge changeset PR, verify npm packages published with `latest` tag\n\n### Manual Testing Steps:\n1. `npm install -g patchy-cli@pr-{number}` - verify installs correct binary\n2. `patchy --version` - verify outputs version\n3. `npx patchy-cli --version` - verify works without install\n4. Test on different platforms (Linux, macOS, Windows)\n\n## References\n\n- opencode bin shim: `/home/rich/code/reference-repos/opencode/packages/opencode/bin/opencode`\n- Current PR workflow: `.github/workflows/pr-release.yml`\n- Current build script: `scripts/build.ts`\n","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-10T21:52:29.258163337Z","updated_at":"2025-12-11T12:31:41.440150523Z","closed_at":"2025-12-11T12:31:41.440150523Z"}
{"id":"patchy-6","title":"Implement environment variable support","description":"README documents environment variables but they are NOT implemented. The config resolver only handles CLI flags and JSON config.\n\nRequired env vars to support:\n- PATCHY_REPO_DIR\n- PATCHY_REPO_BASE_DIR\n- PATCHY_PATCHES_DIR\n- PATCHY_CONFIG\n- PATCHY_VERBOSE\n- PATCHY_DRY_RUN\n- PATCHY_REPO_URL\n- PATCHY_REF\n\nImplementation needs:\n1. Update config resolver (src/config/resolver.ts) to read process.env\n2. Maintain precedence: CLI flags \u003e env vars \u003e config file \u003e defaults\n3. Update CLI --help output to mention corresponding env var for each flag (modern CLI best practice)\n4. Example help format: '--repo-dir \u003cpath\u003e  Path to repo [env: PATCHY_REPO_DIR]'\n\nLocation: src/config/resolver.ts","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-08T12:28:10.289417564Z","updated_at":"2025-12-08T12:36:21.690294706Z","closed_at":"2025-12-08T12:36:21.690294706Z"}
{"id":"patchy-60","title":"DRY up src/config/types.ts by deriving types from CONFIG_FIELD_METADATA","description":"# DRY Refactoring of src/config/types.ts\n\n## Overview\n\nRefactor `src/config/types.ts` to derive core config types from `CONFIG_FIELD_METADATA`, eliminating manual duplication while keeping flag types explicit for readability.\n\n## Current State Analysis\n\nThe file has the same fields defined in 3 different casings:\n- `SharedFlags`: kebab-case (`\"repo-url\"`, `\"repo-dir\"`)\n- `CompleteJsonConfig`: snake_case (`repo_url`, `repo_dir`)\n- `CamelCaseResolvedConfig`: camelCase (`repoUrl`, `repoDir`)\n\nPlus `CONFIG_FIELD_METADATA` which maps between all of them.\n\n### Key Discoveries:\n- `CompleteJsonConfig` is only used within `types.ts` to derive `JsonKey` and `ResolvedConfig`\n- `CamelCaseResolvedConfig` is only used within `types.ts` (and its Partial variant)\n- `JsonKey` is used in `resolver.ts` for generic constraints\n- `CONFIG_FIELD_METADATA` is already the source of truth for mappings\n- `SharedFlags` has 8 properties, mostly matching metadata but also includes `config` which is NOT in metadata\n\n### Important Constraint:\n`SharedFlags` includes `config?: string` which is NOT in `CONFIG_FIELD_METADATA`. This is intentional - the config path is handled separately from the config values themselves.\n\n## Desired End State\n\nAfter refactoring:\n1. `JsonKey` derived from `CONFIG_FIELD_METADATA` keys\n2. `CompleteJsonConfig` derived from metadata using type inference\n3. `CamelCaseResolvedConfig` derived using a `SnakeToCamel` utility type\n4. `SharedFlags` remains explicit (includes `config` which isn't in metadata, and deriving it would be ugly)\n5. Command flag types remain explicit (they're semantic with Pick patterns)\n6. All tests pass, no runtime behavior changes\n\n### Verification:\n- `bun run test` passes\n- `bun run typecheck` passes\n- Type inference works correctly in VSCode/IDE\n\n## What We're NOT Doing\n\n- NOT changing `SharedFlags` to be derived (it includes `config` which isn't in metadata)\n- NOT changing command-specific flag types (they use `Pick` patterns meaningfully)\n- NOT changing `CONFIG_FIELD_METADATA` structure\n- NOT changing runtime behavior\n- NOT touching `schemas.ts` (it has its own Zod-based types)\n\n## Implementation Approach\n\nUse TypeScript's type inference to derive types from the `CONFIG_FIELD_METADATA` const object.\n\n## Phase 1: Add Utility Types and Derive Config Types\n\n### Overview\nAdd type utilities and refactor the derived types while keeping explicit types unchanged.\n\n### Changes Required:\n\n#### 1. src/config/types.ts\n\n**Move `CONFIG_FIELD_METADATA` above the types that will derive from it**\n\nThe const must be defined before types that reference it.\n\n**Add SnakeToCamel utility type:**\n\n\\`\\`\\`typescript\ntype SnakeToCamel\u003cS extends string\u003e = S extends \\`\\${infer H}_\\${infer T}\\`\n  ? \\`\\${H}\\${Capitalize\u003cSnakeToCamel\u003cT\u003e\u003e}\\`\n  : S;\n\\`\\`\\`\n\n**Derive JsonKey from metadata:**\n\n\\`\\`\\`typescript\n// Before:\nexport type JsonKey = keyof CompleteJsonConfig;\n\n// After:\nexport type JsonKey = keyof typeof CONFIG_FIELD_METADATA;\n\\`\\`\\`\n\n**Derive CompleteJsonConfig from metadata:**\n\n\\`\\`\\`typescript\n// Before:\nexport type CompleteJsonConfig = {\n  repo_url: string;\n  ref: string;\n  repo_base_dir: string;\n  repo_dir: string;\n  patches_dir: string;\n  verbose: boolean;\n  dry_run: boolean;\n};\n\n// After:\nexport type CompleteJsonConfig = {\n  [K in JsonKey]: (typeof CONFIG_FIELD_METADATA)[K][\"type\"] extends \"boolean\"\n    ? boolean\n    : string;\n};\n\\`\\`\\`\n\n**Derive CamelCaseResolvedConfig from CompleteJsonConfig:**\n\n\\`\\`\\`typescript\n// Before:\nexport type CamelCaseResolvedConfig = {\n  repoUrl: string;\n  repoDir: string;\n  repoBaseDir: string;\n  patchesDir: string;\n  ref: string;\n  verbose: boolean;\n  dryRun: boolean;\n};\n\n// After:\nexport type CamelCaseResolvedConfig = {\n  [K in JsonKey as SnakeToCamel\u003cK\u003e]: CompleteJsonConfig[K];\n};\n\\`\\`\\`\n\n**Update CONFIG_FIELD_METADATA satisfies clause:**\n\nThe satisfies clause references `JsonKey` and `SharedFlags`, but now `JsonKey` is derived from the metadata itself. We need to adjust:\n\n\\`\\`\\`typescript\n// Before:\n} as const satisfies Record\u003c\n  JsonKey,\n  {\n    flag: keyof SharedFlags;\n    env: string;\n    type: \"boolean\" | \"string\";\n    name: string;\n    example: string;\n  }\n\u003e;\n\n// After (remove JsonKey from satisfies, keep SharedFlags check):\n} as const satisfies Record\u003c\n  string,\n  {\n    flag: Exclude\u003ckeyof SharedFlags, \"config\"\u003e;\n    env: string;\n    type: \"boolean\" | \"string\";\n    name: string;\n    example: string;\n  }\n\u003e;\n\\`\\`\\`\n\nNote: Using `Exclude\u003ckeyof SharedFlags, \"config\"\u003e` because `config` flag exists but isn't in metadata.\n\n### Final File Structure Order:\n\n1. Imports\n2. `YesFlag` type\n3. `SharedFlags` type (explicit)\n4. Command flag types (explicit)\n5. `CONFIG_FIELD_METADATA` const (must come before derived types)\n6. `SnakeToCamel` utility type\n7. `JsonKey` (derived from metadata)\n8. `CompleteJsonConfig` (derived from metadata)\n9. `ResolvedConfig` (extends CompleteJsonConfig)\n10. `CamelCaseResolvedConfig` (derived via SnakeToCamel)\n11. Partial type aliases\n\n### Success Criteria:\n\n#### Automated Verification:\n- [ ] `bun run typecheck` passes\n- [ ] `bun run test` passes\n- [ ] `bun run lint` passes (if exists)\n\n#### Manual Verification:\n- [ ] IDE shows correct type inference for derived types\n- [ ] Hover over `JsonKey` shows: `\"repo_url\" | \"ref\" | \"repo_base_dir\" | \"repo_dir\" | \"patches_dir\" | \"verbose\" | \"dry_run\"`\n- [ ] Hover over `CompleteJsonConfig` shows all properties with correct types\n- [ ] Hover over `CamelCaseResolvedConfig` shows camelCase properties\n\n---\n\n## Testing Strategy\n\n### Automated Tests:\n- Existing tests in `resolver.test.ts` should pass unchanged\n- Type checking validates the derived types are correct\n\n### Manual Verification:\n1. In VSCode, hover over `JsonKey` - should show union of snake_case keys\n2. Hover over `CompleteJsonConfig` - should show object with all properties\n3. Hover over `CamelCaseResolvedConfig` - should show camelCase properties\n4. Verify no red squiggles in `resolver.ts` which heavily uses these types\n\n## References\n\n- `src/config/types.ts:86-145` - CONFIG_FIELD_METADATA definition\n- `src/config/resolver.ts:15-20` - imports from types.ts\n- `src/config/resolver.ts:29-71` - heavy usage of JsonKey and CONFIG_FIELD_METADATA","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T13:00:25.145820946Z","updated_at":"2025-12-11T17:56:51.450496669Z","closed_at":"2025-12-11T17:56:51.450496669Z"}
{"id":"patchy-61","title":"Move validation.ts and jsonc.ts from src/config/ to lib/","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T14:50:11.414275286Z","updated_at":"2025-12-11T14:52:05.853081454Z","closed_at":"2025-12-11T14:52:05.853081454Z"}
{"id":"patchy-62","title":"DRY up config types by making CONFIG_FIELD_METADATA single source of truth","description":"## Goal\n\nMake `CONFIG_FIELD_METADATA` the single source of truth for all config-related definitions, eliminating duplication across:\n- `src/config/types.ts` - TypeScript types + metadata\n- `src/config/schemas.ts` - Zod validation schemas  \n- `src/commands/shared-parameters.ts` - Stricli CLI flags\n- `src/constants.ts` - Env var exports\n\n## Implementation Steps\n\n### Step 1: Expand CONFIG_FIELD_METADATA in types.ts\nAdd `brief` field for CLI descriptions. Keep env vars inline (not imported from constants). Also add `CONFIG_FLAG_METADATA` for the special `config` flag.\n\n### Step 2: Generate Zod schemas in schemas.ts\nUse `buildZodField()` helper to generate schemas from metadata instead of hardcoding field names.\n\n### Step 3: Generate CLI flags in shared-parameters.ts\nUse `buildFlag()` helper to generate Stricli flags from metadata. Keep `applyFlags` and `yesFlag` as explicit additions.\n\n### Step 4: Update constants.ts\nDerive env var exports from metadata for backwards compatibility:\n```typescript\nexport const PATCHY_REPO_URL_ENV_VAR = CONFIG_FIELD_METADATA.repo_url.env;\n```\n\n### Step 5: Update imports in types.ts\nRemove env var imports from constants, since they're now inline in metadata.\n\n### Step 6: Update checkout/command.ts\nReplace `PATCHY_REF_ENV_VAR` import with `CONFIG_FIELD_METADATA.ref.env`.\n\n### Step 7: Update clone/impl.ts\nReplace `PATCHY_REPO_BASE_DIR_ENV_VAR` import with `CONFIG_FIELD_METADATA.repo_base_dir.env`.\n\n## Files to Modify\n\n| File | Change |\n|------|--------|\n| `src/config/types.ts` | Expand metadata with `brief`, add `CONFIG_FLAG_METADATA` |\n| `src/config/schemas.ts` | Generate Zod schemas from metadata |\n| `src/commands/shared-parameters.ts` | Generate CLI flags from metadata |\n| `src/constants.ts` | Derive from metadata |\n| `src/commands/repo/checkout/command.ts` | Use metadata for env var |\n| `src/commands/repo/clone/impl.ts` | Use metadata for env var |\n\n## Verification\n\n```bash\n# 1. Type check\nbun run typecheck\n\n# 2. Run full test suite\nbun run test\n\n# 3. Run local-ci (linting + tests)\nbun run local-ci\n\n# 4. Manual CLI verification\nbun run dev -- --help\nbun run dev -- apply --help\nbun run dev -- repo clone --help\nbun run dev -- repo checkout --help\n\n# 5. Verify env var help text shows correctly\nbun run dev -- apply --help | grep \"env:\"\n```\n\n## Full plan details\n\nSee `/home/rich/.claude/plans/reflective-mixing-meadow.md`","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T14:53:49.901443515Z","updated_at":"2025-12-11T15:00:38.430393027Z","closed_at":"2025-12-11T15:00:38.430393027Z"}
{"id":"patchy-63","title":"Check if ts-essentials can simplify other custom type definitions","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T17:15:32.544555577Z","updated_at":"2025-12-11T17:56:46.983625598Z","closed_at":"2025-12-11T17:56:46.983625598Z"}
{"id":"patchy-64","title":"Colocate tests using blah.test.ts pattern","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T17:33:24.894842252Z","updated_at":"2025-12-11T17:49:39.153158888Z","closed_at":"2025-12-11T17:49:39.153158888Z"}
{"id":"patchy-65","title":"Move config into lib/","description":"","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-11T17:33:54.37702159Z","updated_at":"2025-12-11T17:33:54.37702159Z"}
{"id":"patchy-66","title":"Create lib/flags for --yes flag","description":"","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T17:33:54.410264306Z","updated_at":"2025-12-11T17:42:05.792340581Z","closed_at":"2025-12-11T17:42:05.792340581Z","dependencies":[{"issue_id":"patchy-66","depends_on_id":"patchy-65","type":"blocks","created_at":"0001-01-01T00:00:00Z","created_by":""}]}
{"id":"patchy-67","title":"Colocate e2e tests with source modules using blah.e2e.test.ts pattern","description":"## Summary\n\nColocate e2e tests with their corresponding source modules, following the pattern established in PR #120 for unit tests.\n\n## Current State\n\nE2E tests are in a separate `src/e2e/` directory:\n- `src/e2e/apply.test.ts`\n- `src/e2e/generate.test.ts`\n- `src/e2e/init.test.ts`\n- `src/e2e/repo-checkout.test.ts`\n- `src/e2e/repo-reset.test.ts`\n- `src/e2e/test-utils.test.ts`\n\n## Desired State\n\nMove e2e tests next to their source modules using the `.e2e.test.ts` naming convention:\n- `src/commands/apply.e2e.test.ts`\n- `src/commands/generate.e2e.test.ts`\n- `src/commands/init.e2e.test.ts`\n- `src/commands/repo-checkout.e2e.test.ts` (or wherever the source is)\n- `src/commands/repo-reset.e2e.test.ts` (or wherever the source is)\n\n## Tasks\n\n1. Identify which source module each e2e test corresponds to\n2. Rename and move each test file to be colocated with its source\n3. Update any shared test utilities (test-utils.test.ts) - consider placing in a shared location or splitting\n4. Update any imports in the test files\n5. Verify all tests still pass\n\n## Notes\n\n- The `.e2e.test.ts` suffix distinguishes e2e tests from unit tests (`.test.ts`)\n- This follows the same colocation principle from PR #120","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T18:00:52.39781791Z","updated_at":"2025-12-13T15:46:07.759177254Z","closed_at":"2025-12-13T15:46:07.759177254Z"}
{"id":"patchy-68","title":"Extract absolute path resolution from createMergedConfig","description":"## Overview\nRefactor `createMergedConfig` to separate the absolute path resolution into a new `createEnrichedMergedConfig` function. This improves separation of concerns - the base function handles config merging, the enriched function adds resolved absolute paths.\n\n## Key Decisions\n- **Keep `MergedConfig` name** for the base type (without absolute paths)\n- **Create `EnrichedMergedConfig`** for the type that includes absolute paths\n\n## Files to Modify\n\n### `src/config/config.ts`\n1. Update `MergedConfig` type to remove `absoluteRepoBaseDir`, `absoluteRepoDir`, `absolutePatchesDir`\n2. Update `ResolvedConfig` type similarly (or keep it if it's meant to always have absolute paths - need to check usage)\n3. Create new `EnrichedMergedConfig` type that extends `MergedConfig` with the absolute path fields\n\n### `src/config/resolver.ts`\n1. Remove absolute path computation from `createMergedConfig` (lines 164-171)\n2. Create new `createEnrichedMergedConfig` function that:\n   - Takes same params as `createMergedConfig`\n   - Calls `createMergedConfig` internally\n   - Adds the three absolute path fields\n   - Runs `calcError` validation\n   - Returns `EnrichedMergedConfig`\n3. Move `calcError` call from `createMergedConfig` to `createEnrichedMergedConfig`\n\n## Architecture\n- `createMergedConfig` returns `MergedConfig` (no absolute paths, no path validation)\n- `createEnrichedMergedConfig` calls `createMergedConfig` internally, adds absolute paths, runs path validation\n- Callers that need absolute paths use `createEnrichedMergedConfig`\n\n## Affected Callers (switch to `createEnrichedMergedConfig`)\n- `src/commands/apply/impl.ts`\n- `src/commands/generate/impl.ts`\n- `src/commands/repo/checkout/impl.ts`\n- `src/commands/repo/clone/impl.ts`\n- `src/commands/repo/reset/impl.ts`\n\n## Test Updates\n- Update tests to use `createEnrichedMergedConfig` where absolute paths are tested\n- Update type imports/assertions\n\n## Execution Order\n1. Update types in `config.ts` - add `EnrichedMergedConfig`, update `MergedConfig` to remove absolute fields\n2. Create `createEnrichedMergedConfig` function in `resolver.ts`\n3. Move `calcError` (path validation) into `createEnrichedMergedConfig`\n4. Remove absolute path logic from `createMergedConfig`\n5. Update all callers to use `createEnrichedMergedConfig`\n6. Update tests\n7. Run tests to verify no regressions","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T18:24:38.192268609Z","updated_at":"2025-12-11T18:31:59.656274167Z","closed_at":"2025-12-11T18:31:59.656274167Z"}
{"id":"patchy-69","title":"Add e2e tests for repo clone command","description":"**Plan summary**\n\nThe `repo clone` command is the only CLI command missing tests. This command clones an upstream repository to a local directory, with support for optional ref checkout, dry-run mode, and verbose output.\n\n**Motivation**: All other 5 commands (`apply`, `generate`, `init`, `repo checkout`, `repo reset`) have comprehensive e2e tests. The `repo clone` command is production-ready but lacks test coverage, creating a testing gap.\n\n**Key decisions**:\n1. **Use local bare repositories for testing** - Rather than hitting real remote URLs (slow, flaky), we'll create bare git repositories in tmp directories and clone from those using file:// URLs. This matches how professional test suites handle git clone testing.\n2. **Add `file://` URL support to validation** - The current `isValidGitUrl` only accepts HTTPS and SSH URLs. We need to add file:// URL support for local testing.\n3. **Add a `initBareRepoWithCommit` helper** - New helper in `git-helpers.ts` to create bare repos that can be cloned. This is cleaner than modifying existing helpers.\n4. **Follow existing test patterns exactly** - Use same structure as `repo checkout` tests: `beforeEach` for tmp dir, `setupTestWithConfig`, custom matchers, nested describe blocks for dry-run/error cases.\n5. **Test 9 scenarios** - Success (no ref), success (with ref), verbose output, dry-run mode, invalid URL, missing repo_base_dir, target exists, cannot extract repo name, and non-existent remote.\n\n**Files affected**:\n1. `src/lib/validation.ts` - Add file:// URL pattern to `isValidGitUrl` (~2 lines)\n2. `src/testing/git-helpers.ts` - Add `initBareRepoWithCommit` helper (~15 lines)\n3. `src/commands/repo/clone/impl.e2e.test.ts` - New test file (~180 lines)\n\n**Code patterns** (from existing tests):\n```typescript\n// Test setup pattern\nconst ctx = await setupTestWithConfig({\n  tmpDir,\n  createDirectories: { repoBaseDir: \"repos\" },\n  jsonConfig: { repo_base_dir: \"repos\" },\n});\n\n// CLI invocation\nconst result = await runCli(`patchy repo clone --repo-url ${bareRepoUrl}`, tmpDir);\n\n// Assertions\nexpect(result).toSucceed();\nexpect(result.stdout).toContain(\"Successfully cloned\");\n```\n\n**Verification commands**:\n```bash\nbun run test src/commands/repo/clone/impl.e2e.test.ts\nbun run local-ci\n```\n\n---\n\n**Full plan**\n\n## Task 1: Add file:// URL support to validation\n\n**File**: `src/lib/validation.ts`\n\nUpdate `isValidGitUrl` function to accept file:// URLs:\n\n```typescript\nexport const isValidGitUrl = (url: string): boolean =\u003e {\n  const httpsPattern = /^https?:\\/\\/[\\w.-]+\\/[\\w.-]+(\\/[\\w.-]+)+(\\.git)?$/;\n  const sshPattern = /^git@[\\w.-]+:[\\w.-]+(\\/[\\w.-]+)+(\\.git)?$/;\n  const filePattern = /^file:\\/\\/\\/.+$/;\n  const trimmed = url.trim();\n  return (\n    httpsPattern.test(trimmed) ||\n    sshPattern.test(trimmed) ||\n    filePattern.test(trimmed)\n  );\n};\n```\n\n**Checklist**:\n- [ ] Add `filePattern` regex to match `file:///path/to/repo`\n- [ ] Add `filePattern.test(trimmed)` to the return statement\n\n---\n\n## Task 2: Add bare repository helper to git-helpers.ts\n\n**File**: `src/testing/git-helpers.ts`\n\nAdd after `initGitRepoWithCommit` (around line 23):\n\n```typescript\nexport const initBareRepoWithCommit = async (\n  bareRepoDir: string,\n  filename = \"initial.txt\",\n  content = \"initial content\\n\",\n): Promise\u003cvoid\u003e =\u003e {\n  const git = createTestGitClient(bareRepoDir);\n  await git.init(true);\n  const tmpWorkDir = join(bareRepoDir, \"..\", `tmp-work-${Date.now()}`);\n  mkdirSync(tmpWorkDir, { recursive: true });\n  const workGit = createTestGitClient(tmpWorkDir);\n  await workGit.clone(bareRepoDir, \".\");\n  await workGit.addConfig(\"user.email\", \"test@test.com\");\n  await workGit.addConfig(\"user.name\", \"Test User\");\n  writeFileSync(join(tmpWorkDir, filename), content);\n  await workGit.add(\".\");\n  await workGit.commit(\"initial commit\");\n  await workGit.push(\"origin\", \"master\");\n  rmSync(tmpWorkDir, { recursive: true, force: true });\n};\n```\n\n**Checklist**:\n- [ ] Add import for `mkdirSync` from `node:fs` (already has `writeFileSync`)\n- [ ] Add import for `rmSync` from `node:fs`\n- [ ] Add the `initBareRepoWithCommit` function after line 23\n\n---\n\n## Task 3: Create test file for repo clone\n\n**File**: `src/commands/repo/clone/impl.e2e.test.ts` (new file)\n\n```typescript\nimport { beforeEach, describe, expect, it } from \"bun:test\";\nimport { mkdirSync, existsSync } from \"node:fs\";\nimport path from \"node:path\";\nimport {\n  initBareRepoWithCommit,\n  createBranch,\n  createTag,\n  getCurrentBranch,\n} from \"~/testing/git-helpers\";\nimport {\n  generateTmpDir,\n  runCli,\n  setupTestWithConfig,\n} from \"~/testing/test-utils\";\n\ndescribe(\"patchy repo clone\", () =\u003e {\n  let tmpDir: string;\n\n  beforeEach(() =\u003e {\n    tmpDir = generateTmpDir();\n  });\n\n  it(\"should clone a repository\", async () =\u003e {\n    const bareRepoDir = path.join(tmpDir, \"bare-repo.git\");\n    mkdirSync(bareRepoDir, { recursive: true });\n    await initBareRepoWithCommit(bareRepoDir);\n    const bareRepoUrl = `file://${bareRepoDir}`;\n\n    await setupTestWithConfig({\n      tmpDir,\n      createDirectories: { repoBaseDir: \"repos\" },\n      jsonConfig: { repo_base_dir: \"repos\" },\n    });\n\n    const result = await runCli(\n      `patchy repo clone --repo-url ${bareRepoUrl}`,\n      tmpDir,\n    );\n\n    expect(result).toSucceed();\n    expect(result.stdout).toContain(\"Successfully cloned repository\");\n    expect(existsSync(path.join(tmpDir, \"repos\", \"bare-repo\"))).toBe(true);\n  });\n\n  it(\"should clone a repository with ref checkout\", async () =\u003e {\n    const bareRepoDir = path.join(tmpDir, \"bare-repo.git\");\n    mkdirSync(bareRepoDir, { recursive: true });\n    await initBareRepoWithCommit(bareRepoDir);\n\n    const tmpWorkDir = path.join(tmpDir, \"tmp-work\");\n    mkdirSync(tmpWorkDir, { recursive: true });\n    const { createTestGitClient } = await import(\"~/lib/git\");\n    const workGit = createTestGitClient(tmpWorkDir);\n    await workGit.clone(bareRepoDir, \".\");\n    await workGit.addConfig(\"user.email\", \"test@test.com\");\n    await workGit.addConfig(\"user.name\", \"Test User\");\n    await createBranch(tmpWorkDir, \"feature-branch\");\n    await workGit.push(\"origin\", \"feature-branch\");\n\n    const bareRepoUrl = `file://${bareRepoDir}`;\n\n    await setupTestWithConfig({\n      tmpDir,\n      createDirectories: { repoBaseDir: \"repos\" },\n      jsonConfig: { repo_base_dir: \"repos\" },\n    });\n\n    const result = await runCli(\n      `patchy repo clone --repo-url ${bareRepoUrl} --ref feature-branch`,\n      tmpDir,\n    );\n\n    expect(result).toSucceed();\n    expect(result.stdout).toContain(\"Successfully cloned repository\");\n    expect(result.stdout).toContain(\"Checking out feature-branch\");\n\n    const clonedRepoDir = path.join(tmpDir, \"repos\", \"bare-repo\");\n    expect(await getCurrentBranch(clonedRepoDir)).toBe(\"feature-branch\");\n  });\n\n  it(\"should use verbose output when --verbose is set\", async () =\u003e {\n    const bareRepoDir = path.join(tmpDir, \"bare-repo.git\");\n    mkdirSync(bareRepoDir, { recursive: true });\n    await initBareRepoWithCommit(bareRepoDir);\n    const bareRepoUrl = `file://${bareRepoDir}`;\n\n    await setupTestWithConfig({\n      tmpDir,\n      createDirectories: { repoBaseDir: \"repos\" },\n      jsonConfig: { repo_base_dir: \"repos\" },\n    });\n\n    const result = await runCli(\n      `patchy repo clone --repo-url ${bareRepoUrl} --verbose`,\n      tmpDir,\n    );\n\n    expect(result).toSucceed();\n    expect(result.stdout).toContain(\"Repository URL:\");\n    expect(result.stdout).toContain(\"Repository base directory:\");\n    expect(result.stdout).toContain(\"Target directory:\");\n  });\n\n  describe(\"dry-run\", () =\u003e {\n    it(\"should not clone when --dry-run is set\", async () =\u003e {\n      const bareRepoDir = path.join(tmpDir, \"bare-repo.git\");\n      mkdirSync(bareRepoDir, { recursive: true });\n      await initBareRepoWithCommit(bareRepoDir);\n      const bareRepoUrl = `file://${bareRepoDir}`;\n\n      await setupTestWithConfig({\n        tmpDir,\n        createDirectories: { repoBaseDir: \"repos\" },\n        jsonConfig: { repo_base_dir: \"repos\" },\n      });\n\n      const result = await runCli(\n        `patchy repo clone --repo-url ${bareRepoUrl} --dry-run`,\n        tmpDir,\n      );\n\n      expect(result).toSucceed();\n      expect(result.stdout).toContain(\"[DRY RUN] Would clone\");\n      expect(existsSync(path.join(tmpDir, \"repos\", \"bare-repo\"))).toBe(false);\n    });\n\n    it(\"should show ref in dry-run output when --ref is set\", async () =\u003e {\n      const bareRepoDir = path.join(tmpDir, \"bare-repo.git\");\n      mkdirSync(bareRepoDir, { recursive: true });\n      await initBareRepoWithCommit(bareRepoDir);\n      const bareRepoUrl = `file://${bareRepoDir}`;\n\n      await setupTestWithConfig({\n        tmpDir,\n        createDirectories: { repoBaseDir: \"repos\" },\n        jsonConfig: { repo_base_dir: \"repos\" },\n      });\n\n      const result = await runCli(\n        `patchy repo clone --repo-url ${bareRepoUrl} --ref v1.0.0 --dry-run`,\n        tmpDir,\n      );\n\n      expect(result).toSucceed();\n      expect(result.stdout).toContain(\"[DRY RUN] Would checkout ref: v1.0.0\");\n    });\n  });\n\n  describe(\"error cases\", () =\u003e {\n    it(\"should fail with invalid git URL\", async () =\u003e {\n      await setupTestWithConfig({\n        tmpDir,\n        createDirectories: { repoBaseDir: \"repos\" },\n        jsonConfig: { repo_base_dir: \"repos\" },\n      });\n\n      const result = await runCli(\n        `patchy repo clone --repo-url not-a-valid-url`,\n        tmpDir,\n      );\n\n      expect(result).toFail();\n      expect(result.stderr).toContain(\"Invalid Git URL\");\n    });\n\n    it(\"should fail when repo_base_dir is missing\", async () =\u003e {\n      await setupTestWithConfig({\n        tmpDir,\n        jsonConfig: {},\n      });\n\n      const result = await runCli(\n        `patchy repo clone --repo-url https://github.com/user/repo`,\n        tmpDir,\n      );\n\n      expect(result).toFail();\n      expect(result.stderr).toContain(\"Missing required parameter: repo_base_dir\");\n    });\n\n    it(\"should fail when target directory already exists\", async () =\u003e {\n      const bareRepoDir = path.join(tmpDir, \"bare-repo.git\");\n      mkdirSync(bareRepoDir, { recursive: true });\n      await initBareRepoWithCommit(bareRepoDir);\n      const bareRepoUrl = `file://${bareRepoDir}`;\n\n      await setupTestWithConfig({\n        tmpDir,\n        createDirectories: { repoBaseDir: \"repos\" },\n        jsonConfig: { repo_base_dir: \"repos\" },\n      });\n\n      mkdirSync(path.join(tmpDir, \"repos\", \"bare-repo\"), { recursive: true });\n\n      const result = await runCli(\n        `patchy repo clone --repo-url ${bareRepoUrl}`,\n        tmpDir,\n      );\n\n      expect(result).toFail();\n      expect(result.stderr).toContain(\"Target directory already exists\");\n    });\n\n    it(\"should fail when remote repository does not exist\", async () =\u003e {\n      await setupTestWithConfig({\n        tmpDir,\n        createDirectories: { repoBaseDir: \"repos\" },\n        jsonConfig: { repo_base_dir: \"repos\" },\n      });\n\n      const result = await runCli(\n        `patchy repo clone --repo-url file:///nonexistent/repo.git`,\n        tmpDir,\n      );\n\n      expect(result).toFail();\n    });\n  });\n});\n```\n\n**Checklist**:\n- [ ] Create the new test file at `src/commands/repo/clone/impl.e2e.test.ts`\n\n---\n\n## Task 4: Run tests and verify\n\n**Commands**:\n```bash\nbun run test src/commands/repo/clone/impl.e2e.test.ts\n```\n\n**Expected**: All 9 tests pass\n\n**Checklist**:\n- [ ] Run the new tests\n- [ ] Fix any failing tests (update snapshots if needed with `bun run test -- -u`)\n- [ ] Run `bun run local-ci` to ensure all tests pass\n\n---\n\n## Summary\n\n| Task | File | Lines Changed |\n|------|------|---------------|\n| 1 | `src/lib/validation.ts` | +3 lines |\n| 2 | `src/testing/git-helpers.ts` | +17 lines |\n| 3 | `src/commands/repo/clone/impl.e2e.test.ts` | +185 lines (new) |\n| 4 | Verification | N/A |\n\n**Test scenarios covered**:\n1. Clone repository (success)\n2. Clone with ref checkout (success)\n3. Verbose output\n4. Dry-run mode (no clone)\n5. Dry-run with ref\n6. Invalid Git URL (error)\n7. Missing repo_base_dir (error)\n8. Target directory exists (error)\n9. Non-existent remote (error)","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-13T14:29:02.876391307Z","updated_at":"2025-12-13T15:45:58.357089848Z","closed_at":"2025-12-13T15:45:58.357089848Z"}
{"id":"patchy-7","title":"Allow configuring fuzzFactor for patch application","description":"Currently fuzzFactor is hardcoded to 2 in apply-diff.ts. Allow users to configure this via:\n- CLI flag: --fuzz-factor\n- Config: fuzz_factor in patchy.json\n- Env var: PATCHY_FUZZ_FACTOR\n\nHigher values allow patches to apply even when context lines have shifted, but may cause incorrect applications. Default should remain 2.\n","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-08T13:13:06.449587993Z","updated_at":"2025-12-08T18:29:51.596957822Z","closed_at":"2025-12-08T18:29:51.596957822Z"}
{"id":"patchy-70","title":"Improve init command UX","description":"**Plan summary**\n\nImprove the `patchy init` command to provide a better user experience with sensible defaults and fewer required inputs.\n\n**Motivation**: Currently `init` fails because it passes empty strings for `repo_dir` and `repo_base_dir` to a schema that requires all strings to be non-empty. Additionally, the prompt order is suboptimal and asks for unnecessary fields.\n\n**Key decisions:**\n1. Remove `repo_dir` from init entirely - it will be derived from `repo_url` at runtime by other commands using `extractRepoName()`\n2. Add default value `./upstream/` for `repo_base_dir` in metadata\n3. Fix schema to respect `requiredInConfig` metadata instead of blindly requiring all strings\n4. Add gitignore prompt to help users exclude the upstream repo directory\n5. Reorder prompts: patches_dir â†’ repo_base_dir â†’ gitignore â†’ repo_url â†’ ref\n6. Improve \"Next steps\" message to guide user to clone their repo\n\n**Files affected:**\n- `src/cli-fields/metadata.ts` - Add default for `repo_base_dir`\n- `src/cli-fields/schema.ts` - Fix schema to use `requiredInConfig`\n- `src/commands/init/flags.ts` - Remove `repo_dir` flag\n- `src/commands/init/impl.ts` - Rewrite prompts, add gitignore logic\n- `src/commands/init/impl.e2e.test.ts` - Update tests\n\n**Key code patterns:**\n```typescript\n// Clack confirm prompt (from src/commands/repo/reset/impl.ts:54-64)\nconst confirmed = await prompts.confirm({\n  message: `Add ${repoBaseDir} to .gitignore?`,\n  initialValue: true,\n});\n\n// Extract repo name (from src/lib/git.ts:14)\nimport { extractRepoName } from \"~/lib/git\";\nconst repoName = extractRepoName(repoUrl); // \"repo\" from \"https://github.com/user/repo.git\"\n```\n\n**Feedback loop:**\n```bash\nbun run test -- src/commands/init\nbun run local-ci\n```\n\n**Manual testing:**\n```bash\ncd $(mktemp -d) \u0026\u0026 bun run /home/rich/code/patchy/main/src/cli.ts init\n# Should prompt: patches_dir, repo_base_dir, gitignore, repo_url, ref\n# Should create patchy.json without repo_dir\n# Should optionally modify .gitignore\n# Should output: \"Run `patchy repo clone` to clone your repo into ./upstream/\"\n```\n\n---\n\n**Full plan**\n\n## Phase 1: Update metadata defaults\n\n### [ ] 1.1 Add default value for `repo_base_dir` in metadata\n\n**File:** `src/cli-fields/metadata.ts:77-95`\n\nChange `defaultValue: undefined` to `defaultValue: \"./upstream/\"`:\n\n```typescript\nrepo_base_dir: {\n  configField: true,\n  requiredInConfig: false,\n  env: \"PATCHY_REPO_BASE_DIR\",\n  type: \"string\",\n  name: \"Repository base directory\",\n  example: \"./upstream\",\n  defaultValue: \"./upstream/\",  // Changed from undefined\n  validate: (config, _key) =\u003e directoryExists(config, \"absoluteRepoBaseDir\"),\n  stricliFlag: {\n    \"repo-base-dir\": {\n      kind: \"parsed\",\n      parse: String,\n      brief:\n        \"Parent directory where upstream repos are cloned [env: PATCHY_REPO_BASE_DIR]\",\n      optional: true,\n    },\n  },\n},\n```\n\n## Phase 2: Fix schema to respect requiredInConfig\n\n### [ ] 2.1 Update schema to conditionally apply min(1) based on requiredInConfig\n\n**File:** `src/cli-fields/schema.ts:15-26`\n\nReplace the `buildBaseConfigFields` function:\n\n```typescript\nconst buildBaseConfigFields = (): BaseConfigFields =\u003e {\n  const fields: Record\u003cstring, ZodTypeAny\u003e = {};\n  for (const key of JSON_CONFIG_KEYS) {\n    const meta = FLAG_METADATA[key];\n    if (meta.type === \"boolean\") {\n      fields[key] = z.boolean().default(false);\n    } else if (meta.requiredInConfig) {\n      fields[key] = z.string().min(1, `${meta.name} is required`);\n    } else {\n      fields[key] = z.string();\n    }\n  }\n  return fields as BaseConfigFields;\n};\n```\n\n## Phase 3: Update init command flags\n\n### [ ] 3.1 Remove repo_dir flag from init\n\n**File:** `src/commands/init/flags.ts`\n\nRemove line 6 (`...FLAG_METADATA.repo_dir.stricliFlag,`):\n\n```typescript\nimport { FLAG_METADATA } from \"~/cli-fields\";\nimport type { ParsedFlags } from \"~/types/utils\";\n\nexport const initFlags = {\n  ...FLAG_METADATA.repo_base_dir.stricliFlag,\n  ...FLAG_METADATA.patches_dir.stricliFlag,\n  ...FLAG_METADATA.repo_url.stricliFlag,\n  ...FLAG_METADATA.ref.stricliFlag,\n  ...FLAG_METADATA.config.stricliFlag,\n  ...FLAG_METADATA.verbose.stricliFlag,\n  force: {\n    kind: \"boolean\",\n    brief: \"Overwrite existing configuration\",\n    optional: true,\n  },\n} as const;\n\nexport type InitFlags = ParsedFlags\u003ctypeof initFlags\u003e;\n```\n\n## Phase 4: Rewrite init implementation\n\n### [ ] 4.1 Update imports and types\n\n**File:** `src/commands/init/impl.ts:1-23`\n\nReplace the imports and types section:\n\n```typescript\nimport { existsSync, readFileSync } from \"node:fs\";\nimport { appendFile, mkdir, writeFile } from \"node:fs/promises\";\nimport { resolve } from \"node:path\";\nimport * as prompts from \"@clack/prompts\";\nimport { omitBy } from \"es-toolkit\";\nimport {\n  DEFAULT_CONFIG_PATH,\n  getDefaultValue,\n  type JsonConfig,\n  jsonConfigSchema,\n} from \"~/cli-fields\";\nimport type { LocalContext } from \"~/context\";\nimport { isValidGitUrl, validateGitUrl } from \"~/lib/validation\";\nimport { getSchemaUrl } from \"~/version\";\nimport type { InitFlags } from \"./flags\";\n\ntype PromptAnswers = {\n  patchesDir?: string;\n  repoBaseDir?: string;\n  addToGitignore?: boolean;\n  repoUrl?: string;\n  ref?: string;\n};\n```\n\n### [ ] 4.2 Replace implementation function\n\n**File:** `src/commands/init/impl.ts:25-151`\n\nReplace the entire default export function:\n\n```typescript\nexport default async function (\n  this: LocalContext,\n  flags: InitFlags,\n): Promise\u003cvoid\u003e {\n  const configPath = resolve(this.cwd, flags.config ?? DEFAULT_CONFIG_PATH);\n\n  if (!flags.force \u0026\u0026 existsSync(configPath)) {\n    this.process.stderr.write(\n      `Configuration file already exists at ${configPath}\\n`,\n    );\n    this.process.stderr.write(\"Use --force to overwrite\\n\");\n    this.process.exit?.(1);\n    return;\n  }\n\n  if (flags[\"repo-url\"] !== undefined) {\n    if (!flags[\"repo-url\"].trim()) {\n      this.process.stderr.write(\"Repository URL is required\\n\");\n      this.process.exit?.(1);\n      return;\n    }\n    if (!isValidGitUrl(flags[\"repo-url\"])) {\n      this.process.stderr.write(\n        \"Please enter a valid Git URL (https://github.com/owner/repo or git@github.com:owner/repo.git)\\n\",\n      );\n      this.process.exit?.(1);\n      return;\n    }\n  }\n\n  this.process.stdout.write(\"\\nðŸ”§ Let's set up your Patchy project\\n\\n\");\n\n  const answers: PromptAnswers = {};\n\n  // 1. Patches directory\n  if (flags[\"patches-dir\"] === undefined) {\n    const patchesDir = await prompts.text({\n      message: \"Path for patch files:\",\n      placeholder: \"Where generated patch files will be stored\",\n      initialValue: getDefaultValue(\"patches_dir\"),\n    });\n    if (prompts.isCancel(patchesDir)) {\n      this.process.stderr.write(\"Initialization cancelled\\n\");\n      this.process.exit?.(1);\n      return;\n    }\n    answers.patchesDir = patchesDir;\n  }\n\n  // 2. Repo base directory\n  if (flags[\"repo-base-dir\"] === undefined) {\n    const repoBaseDir = await prompts.text({\n      message: \"Directory for upstream repos:\",\n      placeholder: \"Parent directory where upstream repos are cloned\",\n      initialValue: getDefaultValue(\"repo_base_dir\"),\n    });\n    if (prompts.isCancel(repoBaseDir)) {\n      this.process.stderr.write(\"Initialization cancelled\\n\");\n      this.process.exit?.(1);\n      return;\n    }\n    answers.repoBaseDir = repoBaseDir;\n  }\n\n  // 3. Gitignore prompt\n  const repoBaseDir =\n    flags[\"repo-base-dir\"] ??\n    answers.repoBaseDir ??\n    getDefaultValue(\"repo_base_dir\") ??\n    \"\";\n\n  if (repoBaseDir) {\n    const addToGitignore = await prompts.confirm({\n      message: `Add ${repoBaseDir} to .gitignore?`,\n      initialValue: true,\n    });\n    if (prompts.isCancel(addToGitignore)) {\n      this.process.stderr.write(\"Initialization cancelled\\n\");\n      this.process.exit?.(1);\n      return;\n    }\n    answers.addToGitignore = addToGitignore;\n  }\n\n  // 4. Repository URL\n  if (flags[\"repo-url\"] === undefined) {\n    const repoUrl = await prompts.text({\n      message: \"Upstream repository URL:\",\n      placeholder: \"https://github.com/example/repo\",\n      validate: (url) =\u003e {\n        const result = validateGitUrl(url);\n        return result === true ? undefined : result;\n      },\n    });\n    if (prompts.isCancel(repoUrl)) {\n      this.process.stderr.write(\"Initialization cancelled\\n\");\n      this.process.exit?.(1);\n      return;\n    }\n    answers.repoUrl = repoUrl;\n  }\n\n  // 5. Git ref\n  if (flags.ref === undefined) {\n    const ref = await prompts.text({\n      message: \"Git ref to track:\",\n      placeholder: \"Branch, tag, or commit to compare against\",\n      initialValue: getDefaultValue(\"ref\"),\n    });\n    if (prompts.isCancel(ref)) {\n      this.process.stderr.write(\"Initialization cancelled\\n\");\n      this.process.exit?.(1);\n      return;\n    }\n    answers.ref = ref;\n  }\n\n  const finalConfig: JsonConfig = {\n    repo_url: flags[\"repo-url\"] ?? answers.repoUrl ?? \"\",\n    repo_base_dir: repoBaseDir,\n    patches_dir:\n      flags[\"patches-dir\"] ??\n      answers.patchesDir ??\n      getDefaultValue(\"patches_dir\") ??\n      \"\",\n    ref: flags.ref ?? answers.ref ?? getDefaultValue(\"ref\") ?? \"\",\n  };\n\n  // Create patches directory\n  const absolutePatchesDir = resolve(this.cwd, finalConfig.patches_dir ?? \"\");\n  if (finalConfig.patches_dir) {\n    try {\n      await mkdir(absolutePatchesDir, { recursive: true });\n      this.process.stdout.write(\n        `Created patches directory: ${finalConfig.patches_dir}\\n`,\n      );\n    } catch (error) {\n      this.process.stderr.write(\n        `Failed to create patches directory: ${error}\\n`,\n      );\n      this.process.exit?.(1);\n      return;\n    }\n  }\n\n  // Create repo base directory\n  const absoluteRepoBaseDir = resolve(this.cwd, repoBaseDir);\n  if (repoBaseDir) {\n    try {\n      await mkdir(absoluteRepoBaseDir, { recursive: true });\n      this.process.stdout.write(\n        `Created upstream directory: ${repoBaseDir}\\n`,\n      );\n    } catch (error) {\n      this.process.stderr.write(\n        `Failed to create upstream directory: ${error}\\n`,\n      );\n      this.process.exit?.(1);\n      return;\n    }\n  }\n\n  // Handle gitignore\n  if (answers.addToGitignore \u0026\u0026 repoBaseDir) {\n    try {\n      await addToGitignore(this.cwd, repoBaseDir);\n      this.process.stdout.write(`Added ${repoBaseDir} to .gitignore\\n`);\n    } catch (error) {\n      this.process.stderr.write(`Failed to update .gitignore: ${error}\\n`);\n      this.process.exit?.(1);\n      return;\n    }\n  }\n\n  const jsonContent = await generateJsonConfig(finalConfig);\n\n  try {\n    await writeFile(configPath, jsonContent, \"utf8\");\n    this.process.stdout.write(`Created configuration file: ${configPath}\\n`);\n  } catch (error) {\n    this.process.stderr.write(\n      `Failed to create configuration file: ${error}\\n`,\n    );\n    this.process.exit?.(1);\n    return;\n  }\n\n  this.process.stdout.write(\"\\nâœ… Patchy project initialized successfully!\\n\");\n  this.process.stdout.write(\n    `\\nRun \\`patchy repo clone\\` to clone your repo into ${repoBaseDir}\\n`,\n  );\n}\n```\n\n### [ ] 4.3 Add gitignore helper function\n\n**File:** `src/commands/init/impl.ts` (after the main function, before generateJsonConfig)\n\nAdd this new function:\n\n```typescript\nconst addToGitignore = async (cwd: string, entry: string): Promise\u003cvoid\u003e =\u003e {\n  const gitignorePath = resolve(cwd, \".gitignore\");\n  const normalizedEntry = entry.endsWith(\"/\") ? entry : `${entry}/`;\n\n  if (existsSync(gitignorePath)) {\n    const content = readFileSync(gitignorePath, \"utf8\");\n    const lines = content.split(\"\\n\").map((line) =\u003e line.trim());\n    if (lines.includes(normalizedEntry) || lines.includes(entry)) {\n      return;\n    }\n    const separator = content.endsWith(\"\\n\") ? \"\" : \"\\n\";\n    await appendFile(gitignorePath, `${separator}${normalizedEntry}\\n`);\n  } else {\n    await writeFile(gitignorePath, `${normalizedEntry}\\n`);\n  }\n};\n```\n\n### [ ] 4.4 Update generateJsonConfig function\n\n**File:** `src/commands/init/impl.ts` (the generateJsonConfig function at the end)\n\nReplace with:\n\n```typescript\nconst generateJsonConfig = async (config: JsonConfig): Promise\u003cstring\u003e =\u003e {\n  const validatedConfig = jsonConfigSchema.parse(config);\n\n  const cleanedConfig = omitBy(\n    validatedConfig,\n    (value, key) =\u003e\n      value === \"\" ||\n      value == null ||\n      key === \"$schema\" ||\n      (key === \"verbose\" \u0026\u0026 value === false),\n  );\n\n  const jsonData = {\n    $schema: await getSchemaUrl(),\n    ...cleanedConfig,\n  };\n\n  return `${JSON.stringify(jsonData, null, 2)}\\n`;\n};\n```\n\n## Phase 5: Update tests\n\n### [ ] 5.1 Update init e2e tests\n\n**File:** `src/commands/init/impl.e2e.test.ts`\n\nReplace entire file:\n\n```typescript\nimport { beforeEach, describe, expect, it } from \"bun:test\";\nimport { existsSync, readFileSync } from \"node:fs\";\nimport { join } from \"node:path\";\nimport {\n  generateTmpDir,\n  runCli,\n  setupTestWithConfig,\n} from \"~/testing/test-utils\";\nimport { getSchemaUrl } from \"~/version\";\n\ndescribe(\"patchy init\", () =\u003e {\n  let tmpDir: string;\n\n  beforeEach(() =\u003e {\n    tmpDir = generateTmpDir();\n  });\n\n  it(\"should initialize patchy with all flags\", async () =\u003e {\n    await setupTestWithConfig({\n      tmpDir,\n      createDirectories: { repoBaseDir: \"upstream\" },\n    });\n\n    const result = await runCli(\n      `patchy init --repo-url https://github.com/example/test-repo.git --repo-base-dir upstream --patches-dir patches --ref main --config patchy.json --force`,\n      tmpDir,\n    );\n\n    expect(result).toSucceed();\n    const configPath = join(tmpDir, \"patchy.json\");\n    expect(configPath).toExist();\n    const jsonContent = readFileSync(configPath, \"utf-8\").trim();\n\n    const config = JSON.parse(jsonContent);\n    expect(config).toEqual({\n      $schema: await getSchemaUrl(),\n      repo_url: \"https://github.com/example/test-repo.git\",\n      ref: \"main\",\n      repo_base_dir: \"upstream\",\n      patches_dir: \"patches\",\n    });\n  });\n\n  it(\"should not include repo_dir in config\", async () =\u003e {\n    await setupTestWithConfig({\n      tmpDir,\n      createDirectories: { repoBaseDir: \"upstream\" },\n    });\n\n    const result = await runCli(\n      `patchy init --repo-url https://github.com/example/test-repo.git --repo-base-dir upstream --patches-dir patches --ref main --force`,\n      tmpDir,\n    );\n\n    expect(result).toSucceed();\n    const configPath = join(tmpDir, \"patchy.json\");\n    const config = JSON.parse(readFileSync(configPath, \"utf-8\"));\n    expect(config).not.toHaveProperty(\"repo_dir\");\n  });\n\n  describe(\"gitignore\", () =\u003e {\n    it(\"should create .gitignore when it does not exist (via flags, no prompt)\", async () =\u003e {\n      await setupTestWithConfig({\n        tmpDir,\n        createDirectories: { repoBaseDir: \"upstream\" },\n      });\n\n      // Note: gitignore is only modified via interactive prompt, not flags\n      // This test verifies flags-only mode doesn't touch gitignore\n      const result = await runCli(\n        `patchy init --repo-url https://github.com/example/repo.git --repo-base-dir upstream --patches-dir patches --ref main --force`,\n        tmpDir,\n      );\n\n      expect(result).toSucceed();\n      // When using flags, gitignore prompt is shown interactively\n      // In non-interactive mode (flags), gitignore is not modified\n    });\n  });\n\n  describe(\"error cases\", () =\u003e {\n    it(\"should fail with malformed repo url - missing protocol\", async () =\u003e {\n      await setupTestWithConfig({\n        tmpDir,\n        createDirectories: { repoBaseDir: \"upstream\" },\n      });\n\n      const result = await runCli(\n        `patchy init --repo-url github.com/example/repo --repo-base-dir upstream --patches-dir patches --ref main --config patchy.json --force`,\n        tmpDir,\n      );\n\n      expect(result).toFail();\n      expect(result.stderr).toMatchInlineSnapshot(\n        `\"Please enter a valid Git URL (https://github.com/owner/repo or git@github.com:owner/repo.git)\"`,\n      );\n    });\n\n    it(\"should fail with malformed repo url - invalid domain\", async () =\u003e {\n      await setupTestWithConfig({\n        tmpDir,\n        createDirectories: { repoBaseDir: \"upstream\" },\n      });\n\n      const result = await runCli(\n        `patchy init --repo-url https://invalid_domain/repo --repo-base-dir upstream --patches-dir patches --ref main --config patchy.json --force`,\n        tmpDir,\n      );\n\n      expect(result).toFail();\n      expect(result.stderr).toMatchInlineSnapshot(\n        `\"Please enter a valid Git URL (https://github.com/owner/repo or git@github.com:owner/repo.git)\"`,\n      );\n    });\n\n    it(\"should fail with malformed repo url - incomplete path\", async () =\u003e {\n      await setupTestWithConfig({\n        tmpDir,\n        createDirectories: { repoBaseDir: \"upstream\" },\n      });\n\n      const result = await runCli(\n        `patchy init --repo-url https://github.com/ --repo-base-dir upstream --patches-dir patches --ref main --config patchy.json --force`,\n        tmpDir,\n      );\n\n      expect(result).toFail();\n      expect(result.stderr).toContain(\"valid Git URL\");\n    });\n\n    it(\"should fail when config file exists without force flag\", async () =\u003e {\n      await setupTestWithConfig({\n        tmpDir,\n        createDirectories: { repoBaseDir: \"upstream\" },\n        jsonConfig: { hello: \"world\" },\n      });\n\n      await runCli(\n        `patchy init --repo-url https://github.com/example/repo.git --repo-base-dir upstream --patches-dir patches --ref main --config patchy.json --force`,\n        tmpDir,\n      );\n\n      const result = await runCli(\n        `patchy init --repo-url https://github.com/example/another-repo.git --repo-base-dir upstream --patches-dir patches --ref main --config patchy.json`,\n        tmpDir,\n      );\n\n      expect(result).toFail();\n      expect(result.stderr).toMatchInlineSnapshot(\n        `\n        \"Configuration file already exists at \u003cTEST_DIR\u003e/patchy.json\n        Use --force to overwrite\"\n      `,\n      );\n    });\n\n    it(\"should fail with validation error for empty repo_url\", async () =\u003e {\n      await setupTestWithConfig({\n        tmpDir,\n        createDirectories: { repoBaseDir: \"upstream\" },\n      });\n\n      const result = await runCli(\n        `patchy init --repo-url \"\" --repo-base-dir upstream --patches-dir patches --ref main --config patchy.json --force`,\n        tmpDir,\n      );\n\n      expect(result).toFail();\n      expect(result.stderr).toMatchInlineSnapshot(\n        `\"Please enter a valid Git URL (https://github.com/owner/repo or git@github.com:owner/repo.git)\"`,\n      );\n    });\n  });\n});\n```\n\n## Phase 6: Run tests and verify\n\n### [ ] 6.1 Run init tests\n```bash\nbun run test -- src/commands/init\n```\n\n### [ ] 6.2 Run full test suite\n```bash\nbun run local-ci\n```\n\n### [ ] 6.3 Manual test\n```bash\ncd $(mktemp -d) \u0026\u0026 bun run /home/rich/code/patchy/main/src/cli.ts init\n```\n\nExpected prompts in order:\n1. \"Path for patch files:\" (default: ./patches/)\n2. \"Directory for upstream repos:\" (default: ./upstream/)\n3. \"Add ./upstream/ to .gitignore?\" (default: yes)\n4. \"Upstream repository URL:\" (placeholder: https://github.com/example/repo)\n5. \"Git ref to track:\" (default: main)\n\nExpected output:\n- `patchy.json` with repo_url, repo_base_dir, patches_dir, ref (no repo_dir)\n- `.gitignore` with `./upstream/` entry (if confirmed)\n- `./patches/` directory created\n- `./upstream/` directory created\n- Message: \"Run `patchy repo clone` to clone your repo into ./upstream/\"","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-13T16:26:18.350368214Z","updated_at":"2025-12-14T10:24:48.675230989Z","closed_at":"2025-12-14T10:24:48.675230989Z"}
{"id":"patchy-71","title":"Rename repo_base_dir to clones_dir","description":"# Plan: Rename `repo_base_dir` to `clones_dir`\n\n**Plan summary**\n\nThis plan renames the config field `repo_base_dir` â†’ `clones_dir` and changes the default value from `./upstream/` â†’ `./clones/`.\n\n**Motivation**: The name `repo_base_dir` is not immediately clear to users. `clones_dir` is more self-documenting (describes what lives there) and consistent with the existing `patches_dir` (both plural, both describe contents).\n\n**Key decisions**:\n- Plural `clones_dir` (not singular `clone_dir`) to match `patches_dir` convention\n- No backward compatibility / migration - this is a breaking change to the config schema\n- Enriched field becomes `absoluteClonesDir` (was `absoluteRepoBaseDir`)\n\n**Files affected**:\n1. `src/cli-fields/metadata.ts` - Definition update (key, env, name, example, default, brief, stricliFlag key)\n2. `src/cli-fields/enriched-fields.ts` - Rename `absoluteRepoBaseDir` â†’ `absoluteClonesDir`\n3. `src/cli-fields/resolver.ts` - Update destructuring and enrichment\n4. `src/cli-fields/validators.ts` - Update validator reference\n5. `src/commands/*/flags.ts` - Update metadata reference (6 files)\n6. `src/commands/*/impl.ts` - Update runtime usage (5 files)\n7. `src/commands/init/impl.ts` - Update prompts, messages, and config generation\n8. `README.md` - Update documentation\n9. All test files - Update assertions and fixtures\n\n**Pattern for the rename**:\n```\nrepo_base_dir    â†’ clones_dir        (config key, TypeScript property)\n--repo-base-dir  â†’ --clones-dir      (CLI flag)\nPATCHY_REPO_BASE_DIR â†’ PATCHY_CLONES_DIR (env var)\nabsoluteRepoBaseDir â†’ absoluteClonesDir (enriched field)\n./upstream/      â†’ ./clones/         (default value)\n```\n\n**Verification**:\n```bash\nbun run test\nbun run build\nbun run dev init --help  # Check flag name shows --clones-dir\n```\n\n---\n\n## Full Plan\n\n### Phase 1: Core Type System Changes\n\n#### [ ] 1.1 Update FLAG_METADATA definition\n\n**File**: `src/cli-fields/metadata.ts:77-95`\n\nChange:\n```typescript\n  repo_base_dir: {\n    configField: true,\n    requiredInConfig: false,\n    env: \"PATCHY_REPO_BASE_DIR\",\n    type: \"string\",\n    name: \"Repository base directory\",\n    example: \"./upstream\",\n    defaultValue: \"./upstream/\",\n    validate: (config, _key) =\u003e directoryExists(config, \"absoluteRepoBaseDir\"),\n    stricliFlag: {\n      \"repo-base-dir\": {\n        kind: \"parsed\",\n        parse: String,\n        brief:\n          \"Parent directory where upstream repos are cloned [env: PATCHY_REPO_BASE_DIR]\",\n        optional: true,\n      },\n    },\n  },\n```\n\nTo:\n```typescript\n  clones_dir: {\n    configField: true,\n    requiredInConfig: false,\n    env: \"PATCHY_CLONES_DIR\",\n    type: \"string\",\n    name: \"Clones directory\",\n    example: \"./clones\",\n    defaultValue: \"./clones/\",\n    validate: (config, _key) =\u003e directoryExists(config, \"absoluteClonesDir\"),\n    stricliFlag: {\n      \"clones-dir\": {\n        kind: \"parsed\",\n        parse: String,\n        brief:\n          \"Directory where upstream repos are cloned [env: PATCHY_CLONES_DIR]\",\n        optional: true,\n      },\n    },\n  },\n```\n\n#### [ ] 1.2 Update enriched fields type\n\n**File**: `src/cli-fields/enriched-fields.ts:1-7`\n\nChange:\n```typescript\nexport type EnrichedFields = {\n  absoluteRepoBaseDir: string | undefined;\n  absoluteRepoDir: string | undefined;\n  absolutePatchesDir: string | undefined;\n};\n```\n\nTo:\n```typescript\nexport type EnrichedFields = {\n  absoluteClonesDir: string | undefined;\n  absoluteRepoDir: string | undefined;\n  absolutePatchesDir: string | undefined;\n};\n```\n\n#### [ ] 1.3 Update resolver enrichment logic\n\n**File**: `src/cli-fields/resolver.ts:29-48`\n\nChange:\n```typescript\nconst enrichConfig = (\n  config: MergedConfig,\n  cwd: string,\n): EnrichedMergedConfig =\u003e {\n  const {\n    repo_base_dir: repoBaseDir,\n    repo_dir: repoDir,\n    patches_dir: patchesDir,\n  } = config;\n\n  return {\n    ...config,\n    absoluteRepoBaseDir: repoBaseDir ? resolve(cwd, repoBaseDir) : undefined,\n    absoluteRepoDir:\n      repoBaseDir \u0026\u0026 repoDir\n        ? resolve(cwd, join(repoBaseDir, repoDir))\n        : undefined,\n    absolutePatchesDir: patchesDir ? resolve(cwd, patchesDir) : undefined,\n  };\n};\n```\n\nTo:\n```typescript\nconst enrichConfig = (\n  config: MergedConfig,\n  cwd: string,\n): EnrichedMergedConfig =\u003e {\n  const {\n    clones_dir: clonesDir,\n    repo_dir: repoDir,\n    patches_dir: patchesDir,\n  } = config;\n\n  return {\n    ...config,\n    absoluteClonesDir: clonesDir ? resolve(cwd, clonesDir) : undefined,\n    absoluteRepoDir:\n      clonesDir \u0026\u0026 repoDir\n        ? resolve(cwd, join(clonesDir, repoDir))\n        : undefined,\n    absolutePatchesDir: patchesDir ? resolve(cwd, patchesDir) : undefined,\n  };\n};\n```\n\n#### [ ] 1.4 Update validator reference\n\n**File**: `src/cli-fields/validators.ts:27`\n\nChange:\n```typescript\n  if (!config.absoluteRepoBaseDir || !existsSync(config.absoluteRepoBaseDir)) {\n```\n\nTo:\n```typescript\n  if (!config.absoluteClonesDir || !existsSync(config.absoluteClonesDir)) {\n```\n\n---\n\n### Phase 2: Command Flag Updates\n\n#### [ ] 2.1 Update clone command flags\n\n**File**: `src/commands/repo/clone/flags.ts:6`\n\nChange: `...FLAG_METADATA.repo_base_dir.stricliFlag,`\nTo: `...FLAG_METADATA.clones_dir.stricliFlag,`\n\n#### [ ] 2.2 Update checkout command flags\n\n**File**: `src/commands/repo/checkout/flags.ts:6`\n\nChange: `...FLAG_METADATA.repo_base_dir.stricliFlag,`\nTo: `...FLAG_METADATA.clones_dir.stricliFlag,`\n\n#### [ ] 2.3 Update reset command flags\n\n**File**: `src/commands/repo/reset/flags.ts:6`\n\nChange: `...FLAG_METADATA.repo_base_dir.stricliFlag,`\nTo: `...FLAG_METADATA.clones_dir.stricliFlag,`\n\n#### [ ] 2.4 Update init command flags\n\n**File**: `src/commands/init/flags.ts:5`\n\nChange: `...FLAG_METADATA.repo_base_dir.stricliFlag,`\nTo: `...FLAG_METADATA.clones_dir.stricliFlag,`\n\n#### [ ] 2.5 Update apply command flags\n\n**File**: `src/commands/apply/flags.ts:5`\n\nChange: `...FLAG_METADATA.repo_base_dir.stricliFlag,`\nTo: `...FLAG_METADATA.clones_dir.stricliFlag,`\n\n#### [ ] 2.6 Update generate command flags\n\n**File**: `src/commands/generate/flags.ts:5`\n\nChange: `...FLAG_METADATA.repo_base_dir.stricliFlag,`\nTo: `...FLAG_METADATA.clones_dir.stricliFlag,`\n\n---\n\n### Phase 3: Command Implementation Updates\n\n#### [ ] 3.1 Update clone command impl\n\n**File**: `src/commands/repo/clone/impl.ts`\n\nMultiple changes needed - rename all `repoBaseDir` â†’ `clonesDir` and `repo_base_dir` â†’ `clones_dir`:\n\n**Lines 34-44** - Error message and config access:\n```typescript\n  if (!config.clones_dir) {\n    this.process.stderr.write(\n      chalk.red(\n        `Missing required parameter: clones_dir\\nSet --clones-dir flag, ${FLAG_METADATA.clones_dir.env} env var, or clones_dir in config file.\\n`,\n      ),\n    );\n    this.process.exit(1);\n    return;\n  }\n\n  const clonesDir = resolve(this.cwd, config.clones_dir);\n```\n\n**Line 65** - Target directory:\n```typescript\n  const targetDir = join(clonesDir, repoName);\n```\n\n**Line 69** - Verbose output:\n```typescript\n    this.process.stdout.write(`Clones directory: ${clonesDir}\\n`);\n```\n\n**Line 92** - Ensure directory exists:\n```typescript\n  ensureDirExists(clonesDir);\n```\n\n**Line 96** - Create git client:\n```typescript\n  const git = createGitClient(clonesDir);\n```\n\n#### [ ] 3.2 Update apply command impl requiredFields\n\n**File**: `src/commands/apply/impl.ts:92`\n\nChange: `requiredFields: [\"repo_base_dir\", \"repo_dir\", \"patches_dir\"],`\nTo: `requiredFields: [\"clones_dir\", \"repo_dir\", \"patches_dir\"],`\n\n#### [ ] 3.3 Update generate command impl requiredFields\n\n**File**: `src/commands/generate/impl.ts:75`\n\nChange: `requiredFields: [\"repo_base_dir\", \"repo_dir\"],`\nTo: `requiredFields: [\"clones_dir\", \"repo_dir\"],`\n\n#### [ ] 3.4 Update checkout command impl requiredFields\n\n**File**: `src/commands/repo/checkout/impl.ts:34`\n\nChange: `requiredFields: [\"repo_base_dir\", \"repo_dir\"],`\nTo: `requiredFields: [\"clones_dir\", \"repo_dir\"],`\n\n#### [ ] 3.5 Update reset command impl requiredFields\n\n**File**: `src/commands/repo/reset/impl.ts:16`\n\nChange: `requiredFields: [\"repo_base_dir\", \"repo_dir\"],`\nTo: `requiredFields: [\"clones_dir\", \"repo_dir\"],`\n\n---\n\n### Phase 4: Init Command Updates\n\n#### [ ] 4.1 Update init command prompts and logic\n\n**File**: `src/commands/init/impl.ts`\n\nMultiple changes needed:\n\n**Line 20** - Update PromptAnswers type:\n```typescript\ntype PromptAnswers = {\n  patchesDir?: string;\n  clonesDir?: string;  // was repoBaseDir\n  addToGitignore?: boolean;\n  repoUrl?: string;\n  ref?: string;\n};\n```\n\n**Lines 74-86** - Update prompt:\n```typescript\n  if (flags[\"clones-dir\"] === undefined) {\n    const clonesDir = await prompts.text({\n      message: \"Directory for cloned repos:\",\n      placeholder: \"Parent directory where upstream repos are cloned\",\n      initialValue: getDefaultValue(\"clones_dir\"),\n    });\n    if (prompts.isCancel(clonesDir)) {\n      this.process.stderr.write(\"Initialization cancelled\\n\");\n      this.process.exit?.(1);\n      return;\n    }\n    answers.clonesDir = clonesDir;\n  }\n```\n\n**Lines 88-92** - Update variable resolution:\n```typescript\n  const clonesDir =\n    flags[\"clones-dir\"] ??\n    answers.clonesDir ??\n    getDefaultValue(\"clones_dir\") ??\n    \"\";\n```\n\n**Lines 94-110** - Update gitignore logic:\n- Change `flags[\"repo-base-dir\"]` â†’ `flags[\"clones-dir\"]`\n- Change `repoBaseDir` â†’ `clonesDir`\n\n**Lines 143-152** - Update finalConfig:\n```typescript\n  const finalConfig: JsonConfig = {\n    repo_url: flags[\"repo-url\"] ?? answers.repoUrl ?? \"\",\n    clones_dir: clonesDir,\n    patches_dir:\n      flags[\"patches-dir\"] ??\n      answers.patchesDir ??\n      getDefaultValue(\"patches_dir\") ??\n      \"\",\n    ref: flags.ref ?? answers.ref ?? getDefaultValue(\"ref\") ?? \"\",\n  };\n```\n\n**Lines 170-184** - Update directory creation:\n```typescript\n  const absoluteClonesDir = resolve(this.cwd, clonesDir);\n  if (clonesDir) {\n    try {\n      await mkdir(absoluteClonesDir, { recursive: true });\n      prompts.log.step(\n        `Created clones directory: ${chalk.cyan(clonesDir)}`,\n      );\n    } catch (error) {\n      this.process.stderr.write(\n        `Failed to create clones directory: ${error}\\n`,\n      );\n      this.process.exit?.(1);\n      return;\n    }\n  }\n```\n\n**Lines 186-197** - Update gitignore section:\n- Change `repoBaseDir` â†’ `clonesDir` throughout\n\n**Line 216** - Update outro message:\n```typescript\n  this.process.stdout.write(\n    `\\nRun ${chalk.cyan(\"patchy repo clone\")} to clone your repo into ${chalk.cyan(clonesDir)}\\n`,\n  );\n```\n\n---\n\n### Phase 5: Documentation Updates\n\n#### [ ] 5.1 Update README.md\n\n**File**: `README.md:50-52`\n\nChange:\n```markdown\n  // Parent directory for cloning repos. You can easily clone more repos here from repo_url.\n  \"repo_base_dir\": \"~/repos\", // Override: --repo-base-dir | env: PATCHY_REPO_BASE_DIR\n```\n\nTo:\n```markdown\n  // Parent directory for cloning repos. You can easily clone more repos here from repo_url.\n  \"clones_dir\": \"./clones/\", // Override: --clones-dir | env: PATCHY_CLONES_DIR\n```\n\n**File**: `README.md:132`\n\nChange: `Clone a repository into a subdirectory of `repo_base_dir`.`\nTo: `Clone a repository into a subdirectory of `clones_dir`.`\n\n**File**: `README.md:135`\n\nChange: `patchy repo clone [--repo-base-dir] [--ref] [--repo-url]`\nTo: `patchy repo clone [--clones-dir] [--ref] [--repo-url]`\n\n---\n\n### Phase 6: Test Updates\n\n#### [ ] 6.1 Update resolver tests\n\n**File**: `src/cli-fields/resolver.test.ts`\n\nGlobal find/replace in this file:\n- `repo_base_dir` â†’ `clones_dir` (config keys)\n- `PATCHY_REPO_BASE_DIR` â†’ `PATCHY_CLONES_DIR` (env vars)\n- `absoluteRepoBaseDir` â†’ `absoluteClonesDir` (enriched fields)\n- `\"repo-base-dir\"` â†’ `\"clones-dir\"` (CLI flags)\n\n#### [ ] 6.2 Update test-utils\n\n**File**: `src/testing/test-utils.ts`\n\nFind and update any `repo_base_dir` references to `clones_dir`\n\n#### [ ] 6.3 Update apply e2e tests\n\n**File**: `src/commands/apply/impl.e2e.test.ts`\n\nGlobal find/replace:\n- `repo_base_dir` â†’ `clones_dir`\n\n#### [ ] 6.4 Update generate e2e tests\n\n**File**: `src/commands/generate/impl.e2e.test.ts`\n\nGlobal find/replace:\n- `repo_base_dir` â†’ `clones_dir`\n\n#### [ ] 6.5 Update init e2e tests\n\n**File**: `src/commands/init/impl.e2e.test.ts`\n\nChange:\n- `repo_base_dir: \"upstream\"` â†’ `clones_dir: \"clones\"`\n\n#### [ ] 6.6 Update clone e2e tests\n\n**File**: `src/commands/repo/clone/impl.e2e.test.ts`\n\nGlobal find/replace:\n- `repo_base_dir` â†’ `clones_dir`\n\nUpdate test description at line 156:\n- `\"should use default repo_base_dir when not specified\"` â†’ `\"should use default clones_dir when not specified\"`\n\n#### [ ] 6.7 Update checkout e2e tests\n\n**File**: `src/commands/repo/checkout/impl.e2e.test.ts`\n\nGlobal find/replace:\n- `repo_base_dir` â†’ `clones_dir`\n\n#### [ ] 6.8 Update test-utils.test.ts\n\n**File**: `src/testing/test-utils.test.ts`\n\nChange:\n- `repo_base_dir: \"/tmp/repos\"` â†’ `clones_dir: \"/tmp/repos\"`\n\n#### [ ] 6.9 Update generate-schema.test.ts\n\n**File**: `scripts/generate-schema.test.ts`\n\nChange:\n- `\"repo_base_dir\"` â†’ `\"clones_dir\"`\n\n---\n\n### Phase 7: Verification\n\n#### [ ] 7.1 Run tests\n\n```bash\nbun run test\n```\n\nExpected: All tests pass\n\n#### [ ] 7.2 Run build\n\n```bash\nbun run build\n```\n\nExpected: Build succeeds without errors\n\n#### [ ] 7.3 Manual verification\n\n```bash\n# Check help shows new flag name\nbun run dev init --help\n\n# Expected output includes: --clones-dir\n\n# Test init creates correct default\nrm -rf /tmp/patchy-test \u0026\u0026 mkdir /tmp/patchy-test \u0026\u0026 cd /tmp/patchy-test\nbun run dev init\n\n# Expected: patchy.json contains \"clones_dir\": \"./clones/\"\n# Expected: ./clones/ directory created\n```\n\n---\n\n## Summary of All Changes\n\n| File | Type of Change |\n|------|---------------|\n| `src/cli-fields/metadata.ts` | Definition rename |\n| `src/cli-fields/enriched-fields.ts` | Type rename |\n| `src/cli-fields/resolver.ts` | Logic update |\n| `src/cli-fields/validators.ts` | Reference update |\n| `src/commands/repo/clone/flags.ts` | Metadata reference |\n| `src/commands/repo/checkout/flags.ts` | Metadata reference |\n| `src/commands/repo/reset/flags.ts` | Metadata reference |\n| `src/commands/init/flags.ts` | Metadata reference |\n| `src/commands/apply/flags.ts` | Metadata reference |\n| `src/commands/generate/flags.ts` | Metadata reference |\n| `src/commands/repo/clone/impl.ts` | Runtime usage |\n| `src/commands/apply/impl.ts` | Required fields |\n| `src/commands/generate/impl.ts` | Required fields |\n| `src/commands/repo/checkout/impl.ts` | Required fields |\n| `src/commands/repo/reset/impl.ts` | Required fields |\n| `src/commands/init/impl.ts` | Prompts \u0026 config |\n| `README.md` | Documentation |\n| `src/cli-fields/resolver.test.ts` | Tests |\n| `src/testing/test-utils.ts` | Test utilities |\n| `src/testing/test-utils.test.ts` | Tests |\n| `src/commands/apply/impl.e2e.test.ts` | Tests |\n| `src/commands/generate/impl.e2e.test.ts` | Tests |\n| `src/commands/init/impl.e2e.test.ts` | Tests |\n| `src/commands/repo/clone/impl.e2e.test.ts` | Tests |\n| `src/commands/repo/checkout/impl.e2e.test.ts` | Tests |\n| `scripts/generate-schema.test.ts` | Tests |","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-13T18:51:06.057718978Z","updated_at":"2025-12-14T10:24:44.990639646Z","closed_at":"2025-12-14T10:24:44.990639646Z"}
{"id":"patchy-72","title":"Clone command: prompt to save repo_dir after successful clone","description":"# Clone Command: Post-Clone repo_dir Prompt\n\n**Plan summary**\n\nAfter a successful `patchy repo clone`, prompt the user to save `repo_dir` to patchy.json if it's not already set (or different from the cloned repo name). This improves UX by automatically configuring the project for subsequent commands.\n\n**Motivation**: Currently after cloning, users must manually edit patchy.json to set `repo_dir`. This creates friction since the clone command knows exactly what value should be set.\n\n**Key decisions**:\n- Only prompt if patchy.json exists (users without config are likely using flags/env intentionally)\n- Use `jsonc-parser` modify/applyEdits to preserve comments when updating\n- Skip prompt entirely in dry-run mode\n- Skip prompt if repo_dir already matches the cloned repo name\n- Skip prompt in non-TTY environments (CI, piped output) - clack prompts hang without TTY\n\n**Files affected**:\n1. `src/lib/jsonc.ts` - Add helper function for updating JSONC files\n2. `src/commands/repo/clone/impl.ts` - Add post-clone prompt logic\n3. `src/commands/repo/clone/impl.e2e.test.ts` - Add tests for new behavior\n\n**Key code patterns**:\n```typescript\n// Using jsonc-parser to update while preserving comments\nimport * as JSONC from \"jsonc-parser\";\nconst edits = JSONC.modify(content, ['repo_dir'], value, { formattingOptions: { insertSpaces: true, tabSize: 2 } });\nconst updated = JSONC.applyEdits(content, edits);\n```\n\n```typescript\n// Clack confirm pattern from repo/reset/impl.ts\nconst confirmed = await prompts.confirm({\n  message: `Save repo_dir: \"${repoName}\" to patchy.json?`,\n  initialValue: true,\n});\nif (prompts.isCancel(confirmed) || !confirmed) {\n  return; // Silent continue, clone already succeeded\n}\n```\n\n**Verification**:\n- `bun run test` to run all tests\n- Manual test: `patchy repo clone --repo-url \u003curl\u003e` and verify prompt appears, updates patchy.json correctly\n\n---\n\n## Full Plan\n\n### Step 1: Add updateJsoncField helper to src/lib/jsonc.ts\n\nFile: `src/lib/jsonc.ts` (lines 93+)\n\n- [ ] Add new function after existing `parseJsonc` function:\n\n```typescript\ntype UpdateResult =\n  | { success: true; content: string }\n  | { success: false; error: string };\n\nexport const updateJsoncField = (\n  jsonString: string,\n  key: string,\n  value: string,\n): UpdateResult =\u003e {\n  const edits = JSONC.modify(jsonString, [key], value, {\n    formattingOptions: { insertSpaces: true, tabSize: 2 },\n  });\n\n  try {\n    const updated = JSONC.applyEdits(jsonString, edits);\n    return { success: true, content: updated };\n  } catch {\n    return { success: false, error: `Failed to update ${key} in config` };\n  }\n};\n```\n\n### Step 2: Add helper function for prompting repo_dir save in clone impl\n\nFile: `src/commands/repo/clone/impl.ts` (add after imports, before default export)\n\n- [ ] Add imports at top of file:\n\n```typescript\nimport { existsSync, readFileSync } from \"node:fs\";\nimport { writeFile } from \"node:fs/promises\";\nimport * as prompts from \"@clack/prompts\";\nimport { DEFAULT_CONFIG_PATH, type JsonConfig } from \"~/cli-fields\";\nimport { parseJsonc, updateJsoncField } from \"~/lib/jsonc\";\n```\n\n- [ ] Add helper function after imports (before `export default`):\n\n```typescript\ntype PromptRepoDirSaveParams = {\n  repoName: string;\n  configPath: string;\n  cwd: string;\n  stdout: NodeJS.WriteStream;\n  stderr: NodeJS.WriteStream;\n};\n\nconst promptRepoDirSave = async ({\n  repoName,\n  configPath,\n  cwd,\n  stdout,\n  stderr,\n}: PromptRepoDirSaveParams): Promise\u003cvoid\u003e =\u003e {\n  if (!process.stdin.isTTY) {\n    return;\n  }\n\n  const absoluteConfigPath = resolve(cwd, configPath);\n\n  if (!existsSync(absoluteConfigPath)) {\n    return;\n  }\n\n  const content = readFileSync(absoluteConfigPath, \"utf8\");\n  const parseResult = parseJsonc\u003cJsonConfig\u003e(content);\n\n  if (!parseResult.success) {\n    return;\n  }\n\n  const currentRepoDir = parseResult.json.repo_dir;\n\n  if (currentRepoDir === repoName) {\n    return;\n  }\n\n  const message = currentRepoDir\n    ? `repo_dir in patchy.json is \"${currentRepoDir}\". Update to \"${repoName}\"?`\n    : `Save repo_dir: \"${repoName}\" to patchy.json?`;\n\n  const confirmed = await prompts.confirm({\n    message,\n    initialValue: true,\n  });\n\n  if (prompts.isCancel(confirmed) || !confirmed) {\n    return;\n  }\n\n  const updateResult = updateJsoncField(content, \"repo_dir\", repoName);\n\n  if (!updateResult.success) {\n    stderr.write(chalk.yellow(`${updateResult.error}\\n`));\n    return;\n  }\n\n  try {\n    await writeFile(absoluteConfigPath, updateResult.content, \"utf8\");\n    stdout.write(chalk.green(`Updated patchy.json with repo_dir: \"${repoName}\"\\n`));\n  } catch (error) {\n    stderr.write(chalk.yellow(`Failed to update patchy.json: ${error}\\n`));\n  }\n};\n```\n\n### Step 3: Call promptRepoDirSave after successful clone\n\nFile: `src/commands/repo/clone/impl.ts` (modify the success path)\n\n- [ ] After the success message (line 123-125), add the prompt call:\n\nCurrent code ends with:\n```typescript\n  this.process.stdout.write(\n    chalk.green(`Successfully cloned repository to ${targetDir}\\n`),\n  );\n}\n```\n\nChange to:\n```typescript\n  this.process.stdout.write(\n    chalk.green(`Successfully cloned repository to ${targetDir}\\n`),\n  );\n\n  if (!dryRun) {\n    await promptRepoDirSave({\n      repoName,\n      configPath: config.config ?? DEFAULT_CONFIG_PATH,\n      cwd: this.cwd,\n      stdout: this.process.stdout,\n      stderr: this.process.stderr,\n    });\n  }\n}\n```\n\n### Step 4: Add e2e tests\n\nFile: `src/commands/repo/clone/impl.e2e.test.ts` (add new describe block after existing tests)\n\n- [ ] Add new test imports if not present:\n\n```typescript\nimport { readFileSync } from \"node:fs\";\n```\n\n- [ ] Add new describe block at end of file (before final closing brace):\n\n```typescript\n  describe(\"repo_dir prompt\", () =\u003e {\n    // Note: These tests run in non-TTY mode, so the prompt is automatically skipped.\n    // They verify the clone succeeds and the prompt logic doesn't break anything.\n\n    it(\"should skip prompt in non-TTY mode (e2e tests)\", async () =\u003e {\n      const bareRepoDir = path.join(tmpDir, \"bare-repo.git\");\n      mkdirSync(bareRepoDir, { recursive: true });\n      await initBareRepoWithCommit(bareRepoDir);\n      const bareRepoUrl = `file://${bareRepoDir}`;\n\n      await setupTestWithConfig({\n        tmpDir,\n        createDirectories: { repoBaseDir: \"repos\" },\n        jsonConfig: { repo_base_dir: \"repos\" },\n      });\n\n      const result = await runCli(\n        `patchy repo clone --repo-url ${bareRepoUrl}`,\n        tmpDir,\n      );\n\n      expect(result).toSucceed();\n      expect(result).toHaveOutput(\"Successfully cloned repository\");\n      // Prompt is skipped in non-TTY, so no update message\n      expect(result).not.toHaveOutput(\"Updated patchy.json\");\n    });\n\n    it(\"should skip prompt when repo_dir already matches\", async () =\u003e {\n      const bareRepoDir = path.join(tmpDir, \"bare-repo.git\");\n      mkdirSync(bareRepoDir, { recursive: true });\n      await initBareRepoWithCommit(bareRepoDir);\n      const bareRepoUrl = `file://${bareRepoDir}`;\n\n      await setupTestWithConfig({\n        tmpDir,\n        createDirectories: { repoBaseDir: \"repos\" },\n        jsonConfig: { repo_base_dir: \"repos\", repo_dir: \"bare-repo\" },\n      });\n\n      const result = await runCli(\n        `patchy repo clone --repo-url ${bareRepoUrl}`,\n        tmpDir,\n      );\n\n      expect(result).toSucceed();\n      expect(result).toHaveOutput(\"Successfully cloned repository\");\n      expect(result).not.toHaveOutput(\"Updated patchy.json\");\n    });\n\n    it(\"should skip prompt in dry-run mode\", async () =\u003e {\n      const bareRepoDir = path.join(tmpDir, \"bare-repo.git\");\n      mkdirSync(bareRepoDir, { recursive: true });\n      await initBareRepoWithCommit(bareRepoDir);\n      const bareRepoUrl = `file://${bareRepoDir}`;\n\n      await setupTestWithConfig({\n        tmpDir,\n        createDirectories: { repoBaseDir: \"repos\" },\n        jsonConfig: { repo_base_dir: \"repos\" },\n      });\n\n      const result = await runCli(\n        `patchy repo clone --repo-url ${bareRepoUrl} --dry-run`,\n        tmpDir,\n      );\n\n      expect(result).toSucceed();\n      expect(result).toHaveOutput(\"[DRY RUN]\");\n      expect(result).not.toHaveOutput(\"repo_dir\");\n    });\n\n    it(\"should skip prompt when patchy.json does not exist\", async () =\u003e {\n      const bareRepoDir = path.join(tmpDir, \"bare-repo.git\");\n      mkdirSync(bareRepoDir, { recursive: true });\n      await initBareRepoWithCommit(bareRepoDir);\n      const bareRepoUrl = `file://${bareRepoDir}`;\n\n      mkdirSync(path.join(tmpDir, \"repos\"), { recursive: true });\n\n      const result = await runCli(\n        `patchy repo clone --repo-url ${bareRepoUrl} --repo-base-dir repos`,\n        tmpDir,\n      );\n\n      expect(result).toSucceed();\n      expect(result).toHaveOutput(\"Successfully cloned repository\");\n    });\n  });\n```\n\n### Step 5: Add unit test for updateJsoncField\n\nFile: `src/lib/jsonc.test.ts` (add new describe block)\n\n- [ ] Add tests for the new helper:\n\n```typescript\ndescribe(\"updateJsoncField\", () =\u003e {\n  it(\"should add a new field to JSON\", () =\u003e {\n    const input = `{\n  \"repo_url\": \"https://github.com/foo/bar\"\n}`;\n    const result = updateJsoncField(input, \"repo_dir\", \"my-repo\");\n\n    expect(result.success).toBe(true);\n    if (result.success) {\n      expect(result.content).toContain('\"repo_dir\": \"my-repo\"');\n      expect(result.content).toContain('\"repo_url\"');\n    }\n  });\n\n  it(\"should update an existing field\", () =\u003e {\n    const input = `{\n  \"repo_url\": \"https://github.com/foo/bar\",\n  \"repo_dir\": \"old-repo\"\n}`;\n    const result = updateJsoncField(input, \"repo_dir\", \"new-repo\");\n\n    expect(result.success).toBe(true);\n    if (result.success) {\n      expect(result.content).toContain('\"repo_dir\": \"new-repo\"');\n      expect(result.content).not.toContain(\"old-repo\");\n    }\n  });\n\n  it(\"should preserve comments\", () =\u003e {\n    const input = `{\n  // This is a comment\n  \"repo_url\": \"https://github.com/foo/bar\"\n}`;\n    const result = updateJsoncField(input, \"repo_dir\", \"my-repo\");\n\n    expect(result.success).toBe(true);\n    if (result.success) {\n      expect(result.content).toContain(\"// This is a comment\");\n    }\n  });\n});\n```\n\n### Step 6: Run tests and verify\n\n- [ ] Run `bun run test` to verify all tests pass\n- [ ] Manual test with a real repo URL to verify interactive behavior\n\n---\n\n## Implementation Notes\n\n**Import changes for src/commands/repo/clone/impl.ts**:\n- Add: `import { writeFile } from \"node:fs/promises\";`\n- Add: `import * as prompts from \"@clack/prompts\";`\n- Change: `import { existsSync } from \"node:fs\";` â†’ `import { existsSync, readFileSync } from \"node:fs\";`\n- Add: `import { DEFAULT_CONFIG_PATH, type JsonConfig } from \"~/cli-fields\";`\n- Add: `import { parseJsonc, updateJsoncField } from \"~/lib/jsonc\";`\n\n**Export changes for src/lib/jsonc.ts**:\n- Add: `export { updateJsoncField }` (or just use named export on the function)","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-13T20:45:59.861504095Z","updated_at":"2025-12-14T10:24:44.011993241Z","closed_at":"2025-12-14T10:24:44.011993241Z"}
{"id":"patchy-73","title":"Only prompt for .gitignore when clonesDir is within cwd","description":"## Problem\nThe `patchy init` command prompts to add `clonesDir` to `.gitignore` unconditionally. If `clonesDir` is outside the cwd (e.g., `/tmp/clones`, `../clones`), adding it to `.gitignore` makes no sense since `.gitignore` only affects files within its directory tree.\n\n## Solution\nAdd a helper function `isPathWithinCwd()` that uses `path.relative()` to check if the resolved path is within cwd.\n\n## Plan\nSee `scratch/plans/2025-12-13-gitignore-prompt-cwd-check.md`","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-13T23:07:16.303530333Z","updated_at":"2025-12-14T10:24:39.683537056Z","closed_at":"2025-12-14T10:24:39.683537056Z"}
{"id":"patchy-74","title":"Add clone prompt to init command","description":"# Plan: Add Clone Prompt to Init Command\n\n**Plan summary**\n\nThis plan modifies the `patchy init` command to prompt users to run `patchy repo clone` immediately after initialization, instead of just printing a suggestion message.\n\n**Motivation**: Currently, after `patchy init` completes, it prints \"Run patchy repo clone to clone your repo into ./clones\". This requires users to manually copy/run the command. By prompting and running clone inline, we provide a seamless onboarding experience.\n\n**Key decisions**:\n- Invoke clone programmatically via `run(app, ['repo', 'clone'], context)` rather than subprocess\n- Only prompt in interactive mode (TTY check)\n- Show success message with next steps after clone completes: \"Now you can edit your clone ./clones/repo and run `patchy generate` to generate patches\"\n\n**Files affected**:\n1. `src/commands/init/impl.ts` - Add confirm prompt after success, invoke clone, show post-clone message\n2. `src/commands/init/impl.e2e.test.ts` - Add tests for the new prompt flow\n\n**Code patterns to follow**:\n- Post-action prompt pattern from `src/commands/repo/clone/impl.ts:26-88` (promptRepoDirSave)\n- TTY detection: `inputStream \u0026\u0026 \"isTTY\" in inputStream \u0026\u0026 inputStream.isTTY`\n- Programmatic command invocation: `await run(app, args, context)` from `src/testing/test-utils.ts:69`\n\n**Feedback loop / verification**:\n```bash\nbun run test -- src/commands/init/impl.e2e.test.ts\nbun run local-ci\n```\n\nManual testing:\n```bash\ncd $(mktemp -d)\nbun run dev init --force\n# Should prompt to clone, say yes, then show success message\n```\n\n---\n\n## Full Plan\n\n### Step 1: Add import for `run` and `app`\n\n- [ ] **File**: `src/commands/init/impl.ts:1-16`\n- [ ] Add imports at top of file:\n\n```typescript\nimport { run } from \"@stricli/core\";\nimport { app } from \"~/app\";\n```\n\nAfter the existing imports (around line 16), add these two new imports.\n\n### Step 2: Extract TTY check to helper\n\n- [ ] **File**: `src/commands/init/impl.ts`\n- [ ] After the `PromptAnswers` type definition (line 24), add:\n\n```typescript\nconst isTTY = (context: LocalContext): boolean =\u003e {\n  const inputStream = context.promptInput;\n  return Boolean(inputStream \u0026\u0026 \"isTTY\" in inputStream \u0026\u0026 inputStream.isTTY);\n};\n```\n\n### Step 3: Create `promptAndRunClone` helper function\n\n- [ ] **File**: `src/commands/init/impl.ts`\n- [ ] After the `isTTY` helper (from step 2), add:\n\n```typescript\ntype PromptCloneParams = {\n  clonesDir: string;\n  context: LocalContext;\n};\n\nconst promptAndRunClone = async ({\n  clonesDir,\n  context,\n}: PromptCloneParams): Promise\u003cvoid\u003e =\u003e {\n  if (!isTTY(context)) {\n    context.process.stdout.write(\n      `\\nRun ${chalk.cyan(\"patchy repo clone\")} to clone your repo into ${chalk.cyan(clonesDir)}\\n`,\n    );\n    return;\n  }\n\n  const prompts = createPrompts(context);\n  const shouldClone = await prompts.confirm({\n    message: `Clone repository into ${chalk.cyan(clonesDir)}?`,\n    initialValue: true,\n  });\n\n  if (prompts.isCancel(shouldClone) || !shouldClone) {\n    context.process.stdout.write(\n      `\\nRun ${chalk.cyan(\"patchy repo clone\")} when you're ready to clone your repo into ${chalk.cyan(clonesDir)}\\n`,\n    );\n    return;\n  }\n\n  context.process.stdout.write(\"\\n\");\n  await run(app, [\"repo\", \"clone\"], context);\n\n  context.process.stdout.write(\n    `\\nNow you can edit your clone ${chalk.cyan(`./${clonesDir}`)} and run ${chalk.cyan(\"patchy generate\")} to generate patches\\n`,\n  );\n};\n```\n\n### Step 4: Replace the existing next-steps message\n\n- [ ] **File**: `src/commands/init/impl.ts:214-217`\n- [ ] Replace:\n\n```typescript\nprompts.outro(chalk.green(\"Patchy initialized successfully!\"));\nthis.process.stdout.write(\n  `\\nRun ${chalk.cyan(\"patchy repo clone\")} to clone your repo into ${chalk.cyan(clonesDir)}\\n`,\n);\n```\n\n- [ ] With:\n\n```typescript\nprompts.outro(chalk.green(\"Patchy initialized successfully!\"));\n\nawait promptAndRunClone({\n  clonesDir,\n  context: this,\n});\n```\n\n### Step 5: Add missing imports to test file\n\n- [ ] **File**: `src/commands/init/impl.e2e.test.ts:1-10`\n- [ ] Update the `node:fs` import to include `mkdirSync`:\n\n```typescript\nimport { existsSync, mkdirSync, readFileSync } from \"node:fs\";\n```\n\n- [ ] Add `path` import after the `node:fs` import:\n\n```typescript\nimport path from \"node:path\";\n```\n\n- [ ] Add `initBareRepoWithCommit` import from git-helpers:\n\n```typescript\nimport { initBareRepoWithCommit } from \"~/testing/git-helpers\";\n```\n\n### Step 6: Update existing interactive test to handle new clone prompt\n\n- [ ] **File**: `src/commands/init/impl.e2e.test.ts:212-243`\n- [ ] The existing test \"should complete init with interactive prompts\" needs to decline the clone prompt (since it uses a fake URL that can't be cloned). Update the test:\n\n```typescript\nit(\"should complete init with interactive prompts\", async () =\u003e {\n  const tmpDir = generateTmpDir();\n  await setupTestWithConfig({\n    tmpDir,\n    createDirectories: {},\n    jsonConfig: {},\n  });\n\n  const { resultPromise, tester } = runCliWithPrompts(\n    \"patchy init --force\",\n    tmpDir,\n  );\n\n  // patches dir prompt - accept default\n  tester.press(\"return\");\n  // clones dir prompt - accept default\n  tester.press(\"return\");\n  // gitignore confirm - accept default (yes)\n  tester.press(\"return\");\n  // repo url prompt\n  tester.type(\"https://github.com/example/repo.git\");\n  tester.press(\"return\");\n  // ref prompt - accept default\n  tester.press(\"return\");\n  // clone prompt - decline (navigate to No and confirm)\n  tester.press(\"right\");\n  tester.press(\"return\");\n\n  const result = await resultPromise;\n  expect(result).toSucceed();\n\n  const configPath = join(tmpDir, \"patchy.json\");\n  expect(configPath).toExist();\n});\n```\n\n### Step 7: Add test for user accepting clone prompt\n\n- [ ] **File**: `src/commands/init/impl.e2e.test.ts`\n- [ ] Add new test after the existing interactive tests (inside the `describe(\"interactive prompts\")` block):\n\n```typescript\nit(\"should prompt to clone and run clone when user accepts\", async () =\u003e {\n  const tmpDir = generateTmpDir();\n  const bareRepoDir = path.join(tmpDir, \"bare-repo.git\");\n  mkdirSync(bareRepoDir, { recursive: true });\n  await initBareRepoWithCommit(bareRepoDir);\n  const bareRepoUrl = `file://${bareRepoDir}`;\n\n  const { resultPromise, tester } = runCliWithPrompts(\n    \"patchy init --force\",\n    tmpDir,\n  );\n\n  // patches dir prompt - accept default\n  tester.press(\"return\");\n  // clones dir prompt - accept default\n  tester.press(\"return\");\n  // gitignore confirm - accept default (yes)\n  tester.press(\"return\");\n  // repo url prompt\n  tester.type(bareRepoUrl);\n  tester.press(\"return\");\n  // ref prompt - accept default\n  tester.press(\"return\");\n  // clone prompt - accept (yes)\n  tester.press(\"return\");\n  // repo_dir save prompt from clone - accept\n  tester.press(\"return\");\n\n  const result = await resultPromise;\n  expect(result).toSucceed();\n  expect(result).toHaveOutput(\"Successfully cloned repository\");\n  expect(result).toHaveOutput(\"patchy generate\");\n\n  // Verify clone actually happened\n  const clonedDir = path.join(tmpDir, \"clones\", \"bare-repo\");\n  expect(existsSync(clonedDir)).toBe(true);\n});\n```\n\n### Step 8: Add test for user declining clone prompt\n\n- [ ] **File**: `src/commands/init/impl.e2e.test.ts`\n- [ ] Add after the previous test (inside the `describe(\"interactive prompts\")` block):\n\n```typescript\nit(\"should show manual clone instructions when user declines clone prompt\", async () =\u003e {\n  const tmpDir = generateTmpDir();\n\n  const { resultPromise, tester } = runCliWithPrompts(\n    \"patchy init --force\",\n    tmpDir,\n  );\n\n  // patches dir prompt - accept default\n  tester.press(\"return\");\n  // clones dir prompt - accept default\n  tester.press(\"return\");\n  // gitignore confirm - accept default (yes)\n  tester.press(\"return\");\n  // repo url prompt\n  tester.type(\"https://github.com/example/repo.git\");\n  tester.press(\"return\");\n  // ref prompt - accept default\n  tester.press(\"return\");\n  // clone prompt - decline (navigate to No and confirm)\n  tester.press(\"right\");\n  tester.press(\"return\");\n\n  const result = await resultPromise;\n  expect(result).toSucceed();\n  expect(result).toHaveOutput(\"patchy repo clone\");\n  expect(result).toHaveOutput(\"when you're ready\");\n  expect(result).not.toHaveOutput(\"Successfully cloned\");\n});\n```\n\n### Step 9: Add test for non-interactive mode (flags provided)\n\n- [ ] **File**: `src/commands/init/impl.e2e.test.ts`\n- [ ] Add this test in the main `describe(\"patchy init\")` block (not inside \"interactive prompts\"):\n\n```typescript\nit(\"should show manual clone instructions in non-interactive mode\", async () =\u003e {\n  const tmpDir = generateTmpDir();\n\n  const result = await runCli(\n    `patchy init --force --patches-dir patches --clones-dir clones --repo-url https://github.com/example/repo.git --ref main --gitignore`,\n    tmpDir,\n  );\n\n  expect(result).toSucceed();\n  expect(result).toHaveOutput(\"Patchy initialized successfully\");\n  expect(result).toHaveOutput(\"patchy repo clone\");\n  // Should NOT contain the next-steps message since clone wasn't run\n  expect(result).not.toHaveOutput(\"patchy generate\");\n});\n```\n\n### Step 10: Run tests to verify\n\n- [ ] Run the init tests:\n\n```bash\nbun run test -- src/commands/init/impl.e2e.test.ts\n```\n\n- [ ] Run full CI:\n\n```bash\nbun run local-ci\n```\n\n### Step 11: Manual verification\n\n- [ ] Test interactive flow:\n\n```bash\ncd $(mktemp -d)\nbun run dev init --force\n# Enter repo URL when prompted\n# Accept clone prompt\n# Verify clone runs and success message shows\n```\n\n- [ ] Test declining clone:\n\n```bash\ncd $(mktemp -d)\nbun run dev init --force\n# Enter repo URL when prompted\n# Decline clone prompt\n# Verify manual instructions shown\n```","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-13T23:19:28.008621346Z","updated_at":"2025-12-14T10:24:38.857892043Z","closed_at":"2025-12-14T10:24:38.857892043Z"}
{"id":"patchy-75","title":"Add cleanup of stale patches to patchy generate","description":"# Plan: Add Cleanup of Stale Patches to `patchy generate`\n\n**Plan summary**\n\nThe `patchy generate` command currently only adds or updates patches for files that have changes in the repo. It does **not** remove stale patches for files that no longer have changes. This causes orphaned patches to accumulate (e.g., if you revert a file, rename a patched file, or delete a patched file).\n\n**Motivation:** Users expect `patchy generate` to produce a patches directory that exactly matches their current repo changes. Stale patches cause confusion and can re-apply unwanted changes when running `patchy apply`.\n\n**Key decisions:**\n1. **Cleanup always happens** - The command will always remove stale patches\n2. **Dry-run shows what would be deleted** - Existing `--dry-run` flag will show stale patches that would be removed\n3. **Calculate expected patches from changes** - Compare existing patches against what changes would generate\n\n**Files affected:**\n- `src/commands/generate/impl.ts` - Add cleanup logic\n- `src/lib/fs.ts` - Add `removeFile` helper\n- `src/commands/generate/impl.e2e.test.ts` - Add cleanup tests\n\n**Key code patterns to follow:**\n\nFile deletion (from `src/testing/git-helpers.ts`):\n```typescript\nimport { rmSync } from \"node:fs\";\nrmSync(path, { force: true });\n```\n\nGet all files in directory (from `src/lib/fs.ts`):\n```typescript\nimport { getAllFiles } from \"~/lib/fs\";\nconst existingPatches = await getAllFiles(absolutePatchesDir);\n```\n\n**Feedback loop:**\n```bash\nbun run test -- src/commands/generate/impl.e2e.test.ts\n```\n\n---\n\n## Full plan\n\n### Phase 1: Add `removeFile` helper to fs.ts\n\n- [ ] **1.1** Add `removeFile` function to `src/lib/fs.ts:31`\n\n```typescript\nexport const removeFile = (filePath: string): void =\u003e {\n  rmSync(filePath, { force: true });\n};\n```\n\nAdd import at line 1:\n```typescript\nimport { existsSync, mkdirSync, rmSync } from \"node:fs\";\n```\n\n### Phase 2: Add cleanup logic to generate command\n\n- [ ] **2.1** Update imports in `src/commands/generate/impl.ts:1-8`\n\nChange line 1 from:\n```typescript\nimport { writeFileSync } from \"node:fs\";\n```\nto:\n```typescript\nimport { existsSync, writeFileSync } from \"node:fs\";\n```\n\nAdd `getAllFiles` to the fs import at line 6:\n```typescript\nimport { ensureDirExists, getAllFiles, removeFile } from \"~/lib/fs\";\n```\n\n- [ ] **2.2** Add helper function to calculate expected patch paths after line 67\n\n```typescript\nconst getExpectedPatchPaths = (operations: PatchToGenerate[]): Set\u003cstring\u003e =\u003e\n  new Set(operations.map((op) =\u003e op.destPath));\n\nconst getStalePatches = async (\n  patchesDir: string,\n  expectedPaths: Set\u003cstring\u003e,\n): Promise\u003cstring[]\u003e =\u003e {\n  if (!existsSync(patchesDir)) {\n    return [];\n  }\n  const existingPatches = await getAllFiles(patchesDir);\n  return existingPatches\n    .map((relativePath) =\u003e join(patchesDir, relativePath))\n    .filter((absolutePath) =\u003e !expectedPaths.has(absolutePath));\n};\n```\n\n- [ ] **2.3** Update dry-run block to show stale patches (around line 102-113)\n\nReplace the dry-run block with:\n```typescript\nif (config.dry_run) {\n  this.process.stdout.write(\n    `[DRY RUN] Would generate patches from ${config.repo_dir} to ${config.patches_dir}\\n`,\n  );\n  this.process.stdout.write(`Found ${operations.length} change(s):\\n`);\n  for (const op of operations) {\n    this.process.stdout.write(\n      `  ${op.type}: ${op.relativePath} -\u003e ${op.destPath}\\n`,\n    );\n  }\n\n  const expectedPaths = getExpectedPatchPaths(operations);\n  const stalePatches = await getStalePatches(absolutePatchesDir, expectedPaths);\n  if (stalePatches.length \u003e 0) {\n    this.process.stdout.write(`\\nWould remove ${stalePatches.length} stale patch(es):\\n`);\n    for (const stalePath of stalePatches) {\n      const relativePath = stalePath.replace(`${absolutePatchesDir}/`, \"\");\n      this.process.stdout.write(`  remove: ${relativePath}\\n`);\n    }\n  }\n  return;\n}\n```\n\n- [ ] **2.4** Add cleanup after patch generation (after line 132, before the success message)\n\nInsert before the final success message:\n```typescript\nconst expectedPaths = getExpectedPatchPaths(operations);\nconst stalePatches = await getStalePatches(absolutePatchesDir, expectedPaths);\n\nfor (const stalePath of stalePatches) {\n  removeFile(stalePath);\n  const relativePath = stalePath.replace(`${absolutePatchesDir}/`, \"\");\n  this.process.stdout.write(`  Removed stale: ${relativePath}\\n`);\n}\n```\n\n- [ ] **2.5** Update \"no changes\" early return to also handle cleanup (around line 91-94)\n\nThe current code returns early when there are no changes. We need to still do cleanup in this case:\n\nReplace:\n```typescript\nif (changes.length === 0) {\n  this.process.stdout.write(\"No changes detected in repository.\\n\");\n  return;\n}\n```\n\nWith:\n```typescript\nif (changes.length === 0) {\n  this.process.stdout.write(\"No changes detected in repository.\\n\");\n\n  const expectedPaths = new Set\u003cstring\u003e();\n  const stalePatches = await getStalePatches(absolutePatchesDir, expectedPaths);\n\n  for (const stalePath of stalePatches) {\n    removeFile(stalePath);\n    const relativePath = stalePath.replace(`${absolutePatchesDir}/`, \"\");\n    this.process.stdout.write(`  Removed stale: ${relativePath}\\n`);\n  }\n\n  if (stalePatches.length \u003e 0) {\n    this.process.stdout.write(`Removed ${stalePatches.length} stale patch(es).\\n`);\n  }\n  return;\n}\n```\n\n- [ ] **2.6** Update success message to include removed count\n\nChange the success message to track and report removed patches:\n```typescript\nconst removedMsg = stalePatches.length \u003e 0 ? `, removed ${stalePatches.length} stale` : \"\";\nthis.process.stdout.write(\n  `Generated ${operations.length} patch(es)${removedMsg} successfully.\\n`,\n);\n```\n\n### Phase 3: Add tests for cleanup behavior\n\n- [ ] **3.1** Add test for removing stale patches in `src/commands/generate/impl.e2e.test.ts`\n\nAdd after the existing tests (before the closing `});`):\n```typescript\nit(\"should remove stale patches that no longer have changes\", async () =\u003e {\n  const tmpDir = generateTmpDir();\n  const ctx = await setupTestWithConfig({\n    tmpDir,\n    createDirectories: {\n      patchesDir: \"patches\",\n      clonesDir: \"repos\",\n      repoDir: \"upstream\",\n    },\n    jsonConfig: {\n      clones_dir: \"repos\",\n      repo_dir: \"upstream\",\n      patches_dir: \"patches\",\n    },\n  });\n\n  const repoDir = assertDefined(ctx.absoluteRepoDir, \"absoluteRepoDir\");\n  const patchesDir = assertDefined(ctx.absolutePatchesDir, \"absolutePatchesDir\");\n\n  await initGitRepoWithCommit(repoDir);\n\n  // Create a stale patch that doesn't correspond to any change\n  await writeFileIn(patchesDir, \"stale-file.txt.diff\", \"old diff content\\n\");\n  await writeFileIn(patchesDir, \"another-stale.txt\", \"old file content\\n\");\n\n  // Make a new change\n  await writeFileIn(repoDir, \"initial.txt\", \"modified content\\n\");\n\n  const result = await runCli(`patchy generate`, tmpDir);\n\n  expect(result).toSucceed();\n  expect(result).toHaveOutput(\"Removed stale: stale-file.txt.diff\");\n  expect(result).toHaveOutput(\"Removed stale: another-stale.txt\");\n  expect(result).toHaveOutput(\"removed 2 stale\");\n\n  // Verify stale patches are gone\n  expect(path.join(patchesDir, \"stale-file.txt.diff\")).not.toExist();\n  expect(path.join(patchesDir, \"another-stale.txt\")).not.toExist();\n\n  // Verify new patch was created\n  expect(path.join(patchesDir, \"initial.txt.diff\")).toExist();\n});\n```\n\n- [ ] **3.2** Add test for dry-run showing stale patches\n\n```typescript\nit(\"should show stale patches in dry-run output\", async () =\u003e {\n  const tmpDir = generateTmpDir();\n  const ctx = await setupTestWithConfig({\n    tmpDir,\n    createDirectories: {\n      patchesDir: \"patches\",\n      clonesDir: \"repos\",\n      repoDir: \"upstream\",\n    },\n    jsonConfig: {\n      clones_dir: \"repos\",\n      repo_dir: \"upstream\",\n      patches_dir: \"patches\",\n    },\n  });\n\n  const repoDir = assertDefined(ctx.absoluteRepoDir, \"absoluteRepoDir\");\n  const patchesDir = assertDefined(ctx.absolutePatchesDir, \"absolutePatchesDir\");\n\n  await initGitRepoWithCommit(repoDir);\n\n  // Create stale patches\n  await writeFileIn(patchesDir, \"stale-file.txt.diff\", \"old diff content\\n\");\n\n  // Make a new change\n  await writeFileIn(repoDir, \"initial.txt\", \"modified content\\n\");\n\n  const result = await runCli(`patchy generate --dry-run`, tmpDir);\n\n  expect(result).toSucceed();\n  expect(result).toHaveOutput(\"Would remove 1 stale patch(es)\");\n  expect(result).toHaveOutput(\"remove: stale-file.txt.diff\");\n\n  // Verify stale patch is NOT actually removed\n  expect(path.join(patchesDir, \"stale-file.txt.diff\")).toExist();\n});\n```\n\n- [ ] **3.3** Add test for nested stale patches\n\n```typescript\nit(\"should remove stale patches in nested directories\", async () =\u003e {\n  const tmpDir = generateTmpDir();\n  const ctx = await setupTestWithConfig({\n    tmpDir,\n    createDirectories: {\n      patchesDir: \"patches\",\n      clonesDir: \"repos\",\n      repoDir: \"upstream\",\n    },\n    jsonConfig: {\n      clones_dir: \"repos\",\n      repo_dir: \"upstream\",\n      patches_dir: \"patches\",\n    },\n  });\n\n  const repoDir = assertDefined(ctx.absoluteRepoDir, \"absoluteRepoDir\");\n  const patchesDir = assertDefined(ctx.absolutePatchesDir, \"absolutePatchesDir\");\n\n  await initGitRepoWithCommit(repoDir);\n\n  // Create nested stale patches\n  await writeFileIn(patchesDir, \"src/old/stale.txt.diff\", \"old diff\\n\");\n\n  // Make a new change\n  await writeFileIn(repoDir, \"initial.txt\", \"modified content\\n\");\n\n  const result = await runCli(`patchy generate`, tmpDir);\n\n  expect(result).toSucceed();\n  expect(result).toHaveOutput(\"Removed stale: src/old/stale.txt.diff\");\n  expect(path.join(patchesDir, \"src/old/stale.txt.diff\")).not.toExist();\n});\n```\n\n- [ ] **3.4** Add test for no changes with stale patches\n\n```typescript\nit(\"should remove stale patches even when repo has no changes\", async () =\u003e {\n  const tmpDir = generateTmpDir();\n  const ctx = await setupTestWithConfig({\n    tmpDir,\n    createDirectories: {\n      patchesDir: \"patches\",\n      clonesDir: \"repos\",\n      repoDir: \"upstream\",\n    },\n    jsonConfig: {\n      clones_dir: \"repos\",\n      repo_dir: \"upstream\",\n      patches_dir: \"patches\",\n    },\n  });\n\n  const repoDir = assertDefined(ctx.absoluteRepoDir, \"absoluteRepoDir\");\n  const patchesDir = assertDefined(ctx.absolutePatchesDir, \"absolutePatchesDir\");\n\n  await initGitRepoWithCommit(repoDir);\n\n  // Create stale patches but no repo changes\n  await writeFileIn(patchesDir, \"stale-file.txt.diff\", \"old diff content\\n\");\n\n  const result = await runCli(`patchy generate`, tmpDir);\n\n  expect(result).toSucceed();\n  expect(result).toHaveOutput(\"No changes detected in repository\");\n  expect(result).toHaveOutput(\"Removed stale: stale-file.txt.diff\");\n  expect(path.join(patchesDir, \"stale-file.txt.diff\")).not.toExist();\n});\n```\n\n### Phase 4: Final verification\n\n- [ ] **4.1** Run tests to verify implementation\n```bash\nbun run test -- src/commands/generate/impl.e2e.test.ts\n```\n\n- [ ] **4.2** Manual testing\n```bash\n# Create test scenario\nmkdir -p /tmp/patchy-test \u0026\u0026 cd /tmp/patchy-test\nmkdir -p repos patches\ngit init repos/upstream\ncd repos/upstream\necho \"test\" \u003e test.txt\ngit add . \u0026\u0026 git commit -m \"init\"\ncd ../..\necho '{\"clones_dir\": \"repos\", \"repo_dir\": \"upstream\", \"patches_dir\": \"patches\"}' \u003e patchy.json\n\n# Create stale patch\necho \"stale\" \u003e patches/stale.diff\n\n# Run generate with no changes - should remove stale\npatchy generate\nls patches  # should be empty\n\n# Make change\necho \"modified\" \u003e repos/upstream/test.txt\n\n# Run generate - should create patch\npatchy generate\nls patches  # should have test.txt.diff\n\n# Add another stale patch\necho \"stale2\" \u003e patches/stale2.diff\n\n# Run generate again - should remove stale2.diff\npatchy generate\nls patches  # should only have test.txt.diff\n\n# Check dry-run shows what would be removed\necho \"stale3\" \u003e patches/stale3.diff\npatchy generate --dry-run\nls patches  # stale3.diff should still exist (dry-run)\n```","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-13T23:20:50.586313016Z","updated_at":"2025-12-14T08:23:05.010762764Z","closed_at":"2025-12-14T08:23:05.010762764Z"}
{"id":"patchy-76","title":"Init prompts to add external paths to .gitignore","description":"When running `patchy init` and choosing a clones directory with `~` (e.g., `~/code/test`), two bugs occur:\n\n**Bug 1: Gitignore prompt for external paths**\nThe CLI prompts to add `~/code/test` to .gitignore even though it's outside the project directory. This was supposedly fixed in commit a12c3ea but the issue persists.\n\n**Bug 2: Tilde not expanded during clone**\nWhen cloning, the `~` is treated as a literal directory name instead of being expanded to the home directory:\n- Expected: `/home/rich/code/test/nix`\n- Actual: `/home/rich/code/patchy/main/~/code/test/nix`\n\n**Enhancement: Improve clone prompt wording**\nChange: `Clone repository into ~/code/test?`\nTo: `Clone repository into ~/code/test now?`\n\n**Full reproduction:**\n```\nâ¯ patchydev init\n$ bun run src/cli.ts init\n\nðŸ”§ Let's set up your Patchy project\n\nâ”‚\nâ—‡  Path for patch files:\nâ”‚  ./patches/\nâ”‚\nâ—‡  Directory for cloned repos:\nâ”‚  ~/code/test\nâ”‚\nâ—‡  Add ~/code/test to .gitignore?\nâ”‚  Yes\nâ”‚\nâ—‡  Upstream repository URL:\nâ”‚  https://github.com/richardgill/nix\nâ”‚\nâ—‡  Git ref to track:\nâ”‚  main\nâ”‚\nâ—‡  Created patches directory: ./patches/\nâ”‚\nâ—‡  Created clones directory: ~/code/test\nâ”‚\nâ—‡  Added ~/code/test to .gitignore\nâ”‚\nâ—‡  Created configuration file: ./patchy.json\nâ”‚\nâ””  Patchy initialized successfully!\n\nâ”‚\nâ—‡  Clone repository into ~/code/test?\nâ”‚  Yes\n\nCloning https://github.com/richardgill/nix to /home/rich/code/patchy/main/~/code/test/nix...\nChecking out main...\nSuccessfully cloned repository to /home/rich/code/patchy/main/~/code/test/nix\n```","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T10:26:13.678589955Z","updated_at":"2025-12-14T10:46:32.428891002Z","closed_at":"2025-12-14T10:46:32.428891002Z"}
{"id":"patchy-77","title":"Clone folder naming: use repo name, increment on clash","description":"First clone should use just the repo name (e.g. richardgill/nix -\u003e nix).\n\nIf subsequent clones clash with an existing folder, increment with a suffix:\n- nix-1\n- nix-2\n- etc.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-14T10:28:50.111736508Z","updated_at":"2025-12-14T10:55:19.391996913Z","closed_at":"2025-12-14T10:55:19.391996913Z"}
{"id":"patchy-78","title":"Fix tilde path display in init success message","description":"## Goal\nChange the init command's clone prompt from:\n```\nClone repository into ./clones/ now?\n```\nto:\n```\nClone firefox into ./clones/ now?\n```\n\n## Changes Required\n\n### File: `src/commands/init/impl.ts`\n\n#### 1. Add import for `extractRepoName`\nAdd to imports at top of file:\n```typescript\nimport { extractRepoName } from \"~/lib/git\";\n```\n\n#### 2. Update `PromptCloneParams` type\nAdd `repoUrl` field:\n```typescript\ntype PromptCloneParams = {\n  clonesDir: string;\n  repoUrl: string;\n  context: LocalContext;\n};\n```\n\n#### 3. Update `promptAndRunClone` function\n- Add `repoUrl` to destructuring\n- Extract repo name from URL\n- Update both prompt message and fallback message to include repo name\n\n#### 4. Update call site\nPass `repoUrl` (from `finalConfig.repo_url`) to `promptAndRunClone`\n\n## Verification\nRun `bun run dev init` in a test directory and verify the prompt shows the repo name.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T11:11:24.172367117Z","updated_at":"2025-12-14T14:18:04.023756795Z","closed_at":"2025-12-14T11:13:26.607262718Z"}
{"id":"patchy-79","title":"Fix .gitignore pattern: remove ./ prefix from clones directory entry","description":"## Problem\n\nWhen `patchy init --gitignore` adds the clones directory to `.gitignore`, it writes `./clones/` instead of `clones/`. The `./` prefix breaks gitignore pattern matching.\n\n## Discovery\n\nDuring testing in the patchy repo:\n\n1. Ran `patchy init --repo-url https://github.com/sindresorhus/p-limit --ref main --gitignore --clones-dir ./clones --patches-dir ./patches`\n2. Then `patchy repo clone`\n3. `git status` showed `clones/` as untracked despite gitignore\n\n**Root cause**: `.gitignore` contained `./clones/` which doesn't match gitignore syntax.\n\n## Gitignore behavior\n\n- âœ… `clones/` - matches directory named \"clones\" anywhere\n- âœ… `/clones/` - matches \"clones\" at repo root only\n- âŒ `./clones/` - invalid pattern, matches nothing\n\n## What happens without proper gitignore\n\nWhen a nested git repo is added without gitignore protection:\n\n```\n$ git add clones/\nwarning: adding embedded git repository: clones/p-limit\n```\n\nGit creates a **gitlink** (mode 160000) - a submodule-style reference that only stores the commit hash, not files. Cloning the parent repo results in an empty directory. This is broken behavior.\n\n## Fix\n\nFind where the gitignore entry is written and change from:\n- `./clones/` â†’ `clones/`\n\nThe entry is likely constructed by prepending `./` to the clones-dir path. Should strip any leading `./` before writing to gitignore, or use a hardcoded pattern without the prefix.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-14T14:24:00.959035558Z","updated_at":"2025-12-15T18:03:52.326067933Z","closed_at":"2025-12-15T18:03:52.326067933Z"}
{"id":"patchy-8","title":"Find generic solution for ProcessExitError re-throw pattern","description":"## Context\n\nMultiple command implementations (clone, reset) have this boilerplate pattern:\n\n```typescript\ntry {\n  // command logic\n} catch (error) {\n  if (error instanceof Error \u0026\u0026 error.name === \"ProcessExitError\") {\n    throw error;\n  }\n  // handle other errors\n}\n```\n\nThis is needed because in tests, `process.exit` throws a `ProcessExitError` that needs to propagate, but we also want to catch and handle other errors gracefully.\n\n## Problem\n\n- Duplicated boilerplate across commands\n- Easy to forget when adding new commands\n- Not obvious why this pattern is needed\n\n## Possible Solutions\n\n1. **Wrapper function** - Create a `withErrorHandling(fn)` HOF that handles this pattern\n2. **Custom error class** - Create a `CommandError` that commands throw, and handle ProcessExitError at a higher level\n3. **Test infrastructure change** - Mock process.exit differently so it doesn't throw\n4. **Stricli integration** - Check if stricli has built-in error handling we can leverage\n\n## Files with this pattern\n\n- src/commands/repo/clone/impl.ts\n- src/commands/repo/reset/impl.ts","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T15:17:07.046756614Z","updated_at":"2025-12-08T17:26:09.934071492Z","closed_at":"2025-12-08T17:26:09.934071492Z"}
{"id":"patchy-80","title":"Fix unpkgs schema - not working","description":"","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-15T15:56:51.317405861Z","updated_at":"2025-12-15T18:27:17.935004172Z","closed_at":"2025-12-15T18:27:17.935004172Z"}
{"id":"patchy-81","title":"Add logo and spruce up README","description":"","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-15T17:53:13.793702413Z","updated_at":"2025-12-15T17:53:13.793702413Z"}
{"id":"patchy-9","title":"Modernize apply and generate commands to use createMergedConfig","description":"## Context\n\nThe `clone` and `reset` commands use modern patterns while `apply` and `generate` use older patterns.\n\n## Current State\n\n| Command | Config | ProcessExitError |\n|---------|--------|------------------|\n| `apply` | `resolveConfig` âŒ | âŒ |\n| `generate` | `resolveConfig` âŒ | âŒ |\n| `clone` | `createMergedConfig` âœ… | âœ… |\n| `reset` | `createMergedConfig` âœ… | âœ… |\n\n## Changes Needed\n\n1. **apply/impl.ts** - Migrate from `resolveConfig` to `createMergedConfig`\n2. **generate/impl.ts** - Migrate from `resolveConfig` to `createMergedConfig`\n\n## Benefits\n\n- Consistent error handling across all commands\n- Synchronous config resolution (no async needed)\n- Result-based error handling instead of throwing\n- Prepares for ProcessExitError solution (patchy-8)\n\n## Files\n\n- src/commands/apply/impl.ts\n- src/commands/generate/impl.ts\n\n## Related\n\n- patchy-8: ProcessExitError generic solution","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T15:29:50.762538739Z","updated_at":"2025-12-08T17:11:37.052778105Z","closed_at":"2025-12-08T17:11:37.052778105Z"}
